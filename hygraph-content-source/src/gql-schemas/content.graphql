# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Entity {
    "The id of the object."
    id: ID!
    "The Stage of an object"
    stage: Stage!
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
    "The Stage of an object"
    stage: Stage!
}

union ComponentModel1Parent = ComponentModel1 | Model2 | Model3

union ComponentModel1multiComponentFieldUnion = ComponentModel1 | ComponentModel2

union ComponentModel2Parent = ComponentModel1 | Model2 | Model3

union Model2multiComponentFieldUnion = ComponentModel1 | ComponentModel2

union Model3listOfMultiComponentsUnion = ComponentModel1 | ComponentModel2

union ScheduledOperationAffectedDocument = Asset | Model1 | Model2 | Model3

union multiToManyReferenceMultiToManyReference = Model1 | Model3

union singleToManyReference2MultiToOneReference2 = Model1 | Model3

union singleToOneReferenceMultiToOneReference = Model1 | Model3

type Aggregate {
    count: Int!
}

"Asset system model"
type Asset implements Entity & Node {
    assetFieldModel1(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `assetFieldModel1` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `assetFieldModel1` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: Model1OrderByInput,
        skip: Int,
        where: Model1WhereInput
    ): [Model1!]!
    "The time the document was created"
    createdAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime!
    "User that created this document"
    createdBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Asset!]!
    "The file name"
    fileName: String!
    "The file handle"
    handle: String!
    "The height of the file"
    height: Float
    "List of Asset versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    listOfAssetsModel3(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `listOfAssetsModel3` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `listOfAssetsModel3` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: Model3OrderByInput,
        skip: Int,
        where: Model3WhereInput
    ): [Model3!]!
    "System Locale field"
    locale: Locale!
    "Get the other localizations for this document"
    localizations(
        "Decides if the current locale should be included or not"
        includeCurrent: Boolean! = false,
        """

        Potential locales that should be returned.

        The order of locales will also override locale fall-backing behaviour in the query's subtree.

        Note any related model with localized fields in the query's subtree will be affected.
        The first locale matching the provided list will be returned, localized entries that do not have the provided locale defined will be filtered out.
        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.

        Consider using this in conjunction with forceParentLocale on the children relation fields.
        """
        locales: [Locale!]! = [en]
    ): [Asset!]!
    "The mime type of the file"
    mimeType: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime
    "User that last published this document"
    publishedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "The file size"
    size: Float
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt(
        "Variation of DateTime field to return, allows value from base document, current localization, or combined by returning the newer value of both"
        variation: SystemDateTimeFieldVariation! = COMBINED
    ): DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Returns information you need to upload the asset. The type of upload is dependant on what you pass into asset creations as upload type."
    upload: AssetUpload
    "Get the url for the asset with provided transformations applied."
    url(transformation: AssetTransformationInput): String!
    "The file width"
    width: Float
}

"A connection to a list of items."
type AssetConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [AssetEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AssetEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Asset!
}

"Asset Upload"
type AssetUpload {
    "Asset Upload Error"
    error: AssetUploadError
    "Expiry Timestamp"
    expiresAt: DateTime
    "Asset Request Data for upload"
    requestPostData: AssetUploadRequestPostData
    "Asset Request Data for upload"
    status: AssetUploadStatus
}

"Represents asset upload error"
type AssetUploadError {
    code: String!
    message: String!
}

"Asset Upload Request Post Data"
type AssetUploadRequestPostData {
    "The algorithm to use in the form field. This value should be passed in the `X-Amz-Algorithm` form field."
    algorithm: String!
    "The credential to use in the form field. This value should be passed in the `X-Amz-Credential` form field."
    credential: String!
    "The date the request was signed, formatted as YYYYMMDDTHHMMSSZ. This value should be passed in the `X-Amz-Date` header."
    date: String!
    "The key to use in the form field. This value should be passed in the `Key` form field."
    key: String!
    "The policy to use in the form field. This value should be passed in the `Policy` form field."
    policy: String!
    "The security token to use in the form field. This field is optional only pass it if its not null. This value should be passed in the `X-Amz-Security-Token` form field if not null."
    securityToken: String
    "The signature to use in the form field. This value should be passed in the `X-Amz-Signature` form field."
    signature: String!
    "The URL to which the file should be uploaded with a POST request."
    url: String!
}

type BatchPayload {
    "The number of nodes that have been affected by the Batch operation."
    count: Long!
}

"Representing a color value comprising of HEX, RGBA and css color values"
type Color {
    css: String!
    hex: Hex!
    rgba: RGBA!
}

type ComponentModel1 implements Entity {
    "The unique identifier"
    id: ID!
    multiComponentField(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `multiComponentField` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `multiComponentField` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): ComponentModel1multiComponentFieldUnion
    singleComponentField(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleComponentField` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleComponentField` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): ComponentModel1
    singleToOneReference(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model2
    "System stage field"
    stage: Stage!
    title: String
}

"A connection to a list of items."
type ComponentModel1Connection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ComponentModel1Edge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ComponentModel1Edge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ComponentModel1!
}

type ComponentModel2 implements Entity {
    "The unique identifier"
    id: ID!
    "System stage field"
    stage: Stage!
    title: String
}

"A connection to a list of items."
type ComponentModel2Connection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ComponentModel2Edge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ComponentModel2Edge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ComponentModel2!
}

type DocumentVersion {
    createdAt: DateTime!
    data: Json
    id: ID!
    revision: Int!
    stage: Stage!
}

"Representing a geolocation point with latitude and longitude"
type Location {
    distance(from: LocationInput!): Float!
    latitude: Float!
    longitude: Float!
}

"Model with different fields"
type Model1 implements Entity & Node {
    assetField(
        """

        Sets the locale of the parent document as the first locale in the fallback locales in the query's subtree.

        Note that `assetField` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, localized entries that do not have the provided locale defined will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `assetField` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, localized entries that do not have the provided locale defined will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        where: AssetSingleRelationWhereInput
    ): Asset
    booleanField: Boolean
    colorField: Color
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    dateField: Date
    datetimeField: DateTime
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Model1!]!
    enumerationField: CustomEnumeration
    floatField: Float
    "List of Model1 versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    integerField: Int
    jsonField: Json
    locationField: Location
    markdownField: String
    multilineField: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    richTextField: RichText
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    singleToManyReference(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: Model2WhereInput
    ): [Model2!]!
    singleToManyReference2(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference2` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: Model2WhereInput
    ): [Model2!]!
    singleToOneReference(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model2
    slug: String!
    "System stage field"
    stage: Stage!
    "Title field"
    title: String!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type Model1Connection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [Model1Edge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type Model1Edge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Model1!
}

"Model with component and reference fields"
type Model2 implements Entity & Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Model2!]!
    "List of Model2 versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    multiComponentField(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `multiComponentField` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `multiComponentField` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model2multiComponentFieldUnion
    "Multi two-way reference. The current reference is many-to-many, a list."
    multiToManyReference(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `multiToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `multiToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int
    ): [multiToManyReferenceMultiToManyReference!]!
    "Multi two-way reference. The current reference is one-to-one, not a list."
    multiToOneReference(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `multiToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `multiToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): singleToOneReferenceMultiToOneReference
    "Multi two-way reference. The current reference is many-to-one, not a list."
    multiToOneReference2(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `multiToOneReference2` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `multiToOneReference2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): singleToManyReference2MultiToOneReference2
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    singleComponentField(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleComponentField` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleComponentField` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): ComponentModel1
    "Single one-way one-to-many reference."
    singleToManyReference(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: Model3OrderByInput,
        skip: Int,
        where: Model3WhereInput
    ): [Model3!]!
    "Single two-way reference. The current reference is one-to-many, a list."
    singleToManyReference3(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference3` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference3` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: Model3OrderByInput,
        skip: Int,
        where: Model3WhereInput
    ): [Model3!]!
    "Single one-way one-to-one reference."
    singleToOneReference(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model3
    "Single two-way many-to-one reference. Current reference is \"to-one\", not a list. The back-reference field in model3 is a list."
    singleToOneReference2(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToOneReference2` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToOneReference2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model3
    "System stage field"
    stage: Stage!
    title: String
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type Model2Connection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [Model2Edge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type Model2Edge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Model2!
}

"Model with list fields"
type Model3 implements Entity & Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [Model3!]!
    "List of Model3 versions"
    history(
        limit: Int! = 10,
        skip: Int! = 0,
        "This is optional and can be used to fetch the document version history for a specific stage instead of the current one"
        stageOverride: Stage
    ): [Version!]!
    "The unique identifier"
    id: ID!
    listOfAssets(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the parent document as the first locale in the fallback locales in the query's subtree.

        Note that `listOfAssets` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, localized entries that do not have the provided locale defined will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `listOfAssets` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, localized entries that do not have the provided locale defined will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: AssetOrderByInput,
        skip: Int,
        where: AssetWhereInput
    ): [Asset!]!
    listOfEnums: [CustomEnumeration!]!
    listOfFloats: [Float!]!
    listOfIntegers: [Int!]!
    listOfMultiComponents(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `listOfMultiComponents` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `listOfMultiComponents` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int
    ): [Model3listOfMultiComponentsUnion!]!
    listOfMultiline: [String!]!
    listOfSingleComponents(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `listOfSingleComponents` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `listOfSingleComponents` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: ComponentModel1OrderByInput,
        skip: Int,
        where: ComponentModel1WhereInput
    ): [ComponentModel1!]!
    listOfStrings: [String!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    scheduledIn(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `scheduledIn` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "Back reference to single two-way reference. The current reference is many-to-one, not a list."
    singleToManyReference(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model2
    "Back reference to multi two-way reference. The current reference is one-to-many, a list."
    singleToManyReference2(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference2` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: Model2WhereInput
    ): [Model2!]!
    "Back reference to multi two-way reference. The current reference is many-to-many, a list."
    singleToManyReference3(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference3` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference3` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int,
        where: Model2WhereInput
    ): [Model2!]!
    "Back reference to single two-way reference. Current reference is one-to-many, a list."
    singleToManyReference4(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToManyReference4` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToManyReference4` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: Model2OrderByInput,
        skip: Int,
        where: Model2WhereInput
    ): [Model2!]!
    "This is a back reference field. The current reference is one-to-one, not a list."
    singleToOneReference(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `singleToOneReference` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): Model2
    "System stage field"
    stage: Stage!
    title: String
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type Model3Connection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [Model3Edge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type Model3Edge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Model3!
}

type Mutation {
    "Create an asset. Use the returned info to finish the creation process by uploading the asset."
    createAsset(data: AssetCreateInput!): Asset
    "Create one model1"
    createModel1(data: Model1CreateInput!): Model1
    "Create one model2"
    createModel2(data: Model2CreateInput!): Model2
    "Create one model3"
    createModel3(data: Model3CreateInput!): Model3
    "Create one scheduledRelease"
    createScheduledRelease(data: ScheduledReleaseCreateInput!): ScheduledRelease
    "Delete one asset from _all_ existing stages. Returns deleted document."
    deleteAsset(
        "Document to delete"
        where: AssetWhereUniqueInput!
    ): Asset
    "Delete many Asset documents"
    deleteManyAssets(
        "Documents to delete"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyAssetsConnection)")
    "Delete many Asset documents, return deleted documents"
    deleteManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Delete many Model1 documents"
    deleteManyModels1(
        "Documents to delete"
        where: Model1ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyModels1Connection)")
    "Delete many Model1 documents, return deleted documents"
    deleteManyModels1Connection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: Model1ManyWhereInput
    ): Model1Connection!
    "Delete many Model2 documents"
    deleteManyModels2(
        "Documents to delete"
        where: Model2ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyModels2Connection)")
    "Delete many Model2 documents, return deleted documents"
    deleteManyModels2Connection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: Model2ManyWhereInput
    ): Model2Connection!
    "Delete many Model3 documents"
    deleteManyModels3(
        "Documents to delete"
        where: Model3ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (deleteManyModels3Connection)")
    "Delete many Model3 documents, return deleted documents"
    deleteManyModels3Connection(
        after: ID,
        before: ID,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to delete"
        where: Model3ManyWhereInput
    ): Model3Connection!
    "Delete one model1 from _all_ existing stages. Returns deleted document."
    deleteModel1(
        "Document to delete"
        where: Model1WhereUniqueInput!
    ): Model1
    "Delete one model2 from _all_ existing stages. Returns deleted document."
    deleteModel2(
        "Document to delete"
        where: Model2WhereUniqueInput!
    ): Model2
    "Delete one model3 from _all_ existing stages. Returns deleted document."
    deleteModel3(
        "Document to delete"
        where: Model3WhereUniqueInput!
    ): Model3
    "Delete and return scheduled operation"
    deleteScheduledOperation(
        "Document to delete"
        where: ScheduledOperationWhereUniqueInput!
    ): ScheduledOperation
    "Delete one scheduledRelease from _all_ existing stages. Returns deleted document."
    deleteScheduledRelease(
        "Document to delete"
        where: ScheduledReleaseWhereUniqueInput!
    ): ScheduledRelease
    "Publish one asset"
    publishAsset(
        "Optional localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: AssetWhereUniqueInput!,
        "Whether to include the default locale when publishBase is set"
        withDefaultLocale: Boolean = true
    ): Asset
    "Publish many Asset documents"
    publishManyAssets(
        "Document localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: AssetManyWhereInput,
        "Whether to include the default locale when publishBase is true"
        withDefaultLocale: Boolean = true
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyAssetsConnection)")
    "Publish many Asset documents"
    publishManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        "Document localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: AssetManyWhereInput,
        "Whether to include the default locale when publishBase is true"
        withDefaultLocale: Boolean = true
    ): AssetConnection!
    "Publish many Model1 documents"
    publishManyModels1(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: Model1ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyModels1Connection)")
    "Publish many Model1 documents"
    publishManyModels1Connection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: Model1ManyWhereInput
    ): Model1Connection!
    "Publish many Model2 documents"
    publishManyModels2(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: Model2ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyModels2Connection)")
    "Publish many Model2 documents"
    publishManyModels2Connection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: Model2ManyWhereInput
    ): Model2Connection!
    "Publish many Model3 documents"
    publishManyModels3(
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: Model3ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (publishManyModels3Connection)")
    "Publish many Model3 documents"
    publishManyModels3Connection(
        after: ID,
        before: ID,
        first: Int,
        "Stage to find matching documents in"
        from: Stage = DRAFT,
        last: Int,
        skip: Int,
        "Stages to publish documents to"
        to: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage to be published"
        where: Model3ManyWhereInput
    ): Model3Connection!
    "Publish one model1"
    publishModel1(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: Model1WhereUniqueInput!
    ): Model1
    "Publish one model2"
    publishModel2(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: Model2WhereUniqueInput!
    ): Model2
    "Publish one model3"
    publishModel3(
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: Model3WhereUniqueInput!
    ): Model3
    "Schedule to publish one asset"
    schedulePublishAsset(
        "Optional localizations to publish"
        locales: [Locale!],
        "Whether to publish the base document"
        publishBase: Boolean = true,
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: AssetWhereUniqueInput!,
        "Whether to include the default locale when publishBase is set"
        withDefaultLocale: Boolean = true
    ): Asset
    "Schedule to publish one model1"
    schedulePublishModel1(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: Model1WhereUniqueInput!
    ): Model1
    "Schedule to publish one model2"
    schedulePublishModel2(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: Model2WhereUniqueInput!
    ): Model2
    "Schedule to publish one model3"
    schedulePublishModel3(
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Publishing target stage"
        to: [Stage!]! = [PUBLISHED],
        "Document to publish"
        where: Model3WhereUniqueInput!
    ): Model3
    "Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishAsset(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Optional locales to unpublish. Unpublishing the default locale will completely remove the document from the selected stages"
        locales: [Locale!],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Unpublish complete document including default localization and relations from stages. Can be disabled."
        unpublishBase: Boolean = true,
        "Document to unpublish"
        where: AssetWhereUniqueInput!
    ): Asset
    "Unpublish one model1 from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishModel1(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: Model1WhereUniqueInput!
    ): Model1
    "Unpublish one model2 from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishModel2(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: Model2WhereUniqueInput!
    ): Model2
    "Unpublish one model3 from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    scheduleUnpublishModel3(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Release at point in time, will create new release containing this operation"
        releaseAt: DateTime,
        "Optionally attach this scheduled operation to an existing release"
        releaseId: String,
        "Document to unpublish"
        where: Model3WhereUniqueInput!
    ): Model3
    "Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishAsset(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Optional locales to unpublish. Unpublishing the default locale will completely remove the document from the selected stages"
        locales: [Locale!],
        "Unpublish complete document including default localization and relations from stages. Can be disabled."
        unpublishBase: Boolean = true,
        "Document to unpublish"
        where: AssetWhereUniqueInput!
    ): Asset
    "Unpublish many Asset documents"
    unpublishManyAssets(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Locales to unpublish"
        locales: [Locale!],
        "Whether to unpublish the base document and default localization"
        unpublishBase: Boolean = true,
        "Identifies documents in each stage"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyAssetsConnection)")
    "Find many Asset documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyAssetsConnection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        "Locales to unpublish"
        locales: [Locale!],
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Whether to unpublish the base document and default localization"
        unpublishBase: Boolean = true,
        "Identifies documents in draft stage"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Unpublish many Model1 documents"
    unpublishManyModels1(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: Model1ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyModels1Connection)")
    "Find many Model1 documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyModels1Connection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: Model1ManyWhereInput
    ): Model1Connection!
    "Unpublish many Model2 documents"
    unpublishManyModels2(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: Model2ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyModels2Connection)")
    "Find many Model2 documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyModels2Connection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: Model2ManyWhereInput
    ): Model2Connection!
    "Unpublish many Model3 documents"
    unpublishManyModels3(
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        "Identifies documents in each stage"
        where: Model3ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (unpublishManyModels3Connection)")
    "Find many Model3 documents that match criteria in specified stage and unpublish from target stages"
    unpublishManyModels3Connection(
        after: ID,
        before: ID,
        first: Int,
        "Stages to unpublish documents from"
        from: [Stage!]! = [PUBLISHED],
        last: Int,
        skip: Int,
        "Stage to find matching documents in"
        stage: Stage = DRAFT,
        "Identifies documents in draft stage"
        where: Model3ManyWhereInput
    ): Model3Connection!
    "Unpublish one model1 from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishModel1(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: Model1WhereUniqueInput!
    ): Model1
    "Unpublish one model2 from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishModel2(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: Model2WhereUniqueInput!
    ): Model2
    "Unpublish one model3 from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishModel3(
        "Stages to unpublish document from"
        from: [Stage!]! = [PUBLISHED],
        "Document to unpublish"
        where: Model3WhereUniqueInput!
    ): Model3
    "Update one asset"
    updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
    "Update many assets"
    updateManyAssets(
        "Updates to document content"
        data: AssetUpdateManyInput!,
        "Documents to apply update on"
        where: AssetManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyAssetsConnection)")
    "Update many Asset documents"
    updateManyAssetsConnection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: AssetUpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: AssetManyWhereInput
    ): AssetConnection!
    "Update many models1"
    updateManyModels1(
        "Updates to document content"
        data: Model1UpdateManyInput!,
        "Documents to apply update on"
        where: Model1ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyModels1Connection)")
    "Update many Model1 documents"
    updateManyModels1Connection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: Model1UpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: Model1ManyWhereInput
    ): Model1Connection!
    "Update many models2"
    updateManyModels2(
        "Updates to document content"
        data: Model2UpdateManyInput!,
        "Documents to apply update on"
        where: Model2ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyModels2Connection)")
    "Update many Model2 documents"
    updateManyModels2Connection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: Model2UpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: Model2ManyWhereInput
    ): Model2Connection!
    "Update many models3"
    updateManyModels3(
        "Updates to document content"
        data: Model3UpdateManyInput!,
        "Documents to apply update on"
        where: Model3ManyWhereInput
    ): BatchPayload! @deprecated(reason: "Please use the new paginated many mutation (updateManyModels3Connection)")
    "Update many Model3 documents"
    updateManyModels3Connection(
        after: ID,
        before: ID,
        "Updates to document content"
        data: Model3UpdateManyInput!,
        first: Int,
        last: Int,
        skip: Int,
        "Documents to apply update on"
        where: Model3ManyWhereInput
    ): Model3Connection!
    "Update one model1"
    updateModel1(data: Model1UpdateInput!, where: Model1WhereUniqueInput!): Model1
    "Update one model2"
    updateModel2(data: Model2UpdateInput!, where: Model2WhereUniqueInput!): Model2
    "Update one model3"
    updateModel3(data: Model3UpdateInput!, where: Model3WhereUniqueInput!): Model3
    "Update one scheduledRelease"
    updateScheduledRelease(data: ScheduledReleaseUpdateInput!, where: ScheduledReleaseWhereUniqueInput!): ScheduledRelease
    "Upsert one asset"
    upsertAsset(upsert: AssetUpsertInput!, where: AssetWhereUniqueInput!): Asset
    "Upsert one model1"
    upsertModel1(upsert: Model1UpsertInput!, where: Model1WhereUniqueInput!): Model1
    "Upsert one model2"
    upsertModel2(upsert: Model2UpsertInput!, where: Model2WhereUniqueInput!): Model2
    "Upsert one model3"
    upsertModel3(upsert: Model3UpsertInput!, where: Model3WhereUniqueInput!): Model3
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Number of items in the current page."
    pageSize: Int
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Query {
    "Retrieve a single asset"
    asset(
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: AssetWhereUniqueInput!
    ): Asset
    "Retrieve document version"
    assetVersion(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple assets"
    assets(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): [Asset!]!
    "Retrieve multiple assets using the Relay connection interface"
    assetsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Asset` will be affected directly by this argument, as well as any other related models with localized fields in the query's subtree.
        The first locale matching the provided list will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): AssetConnection!
    "Fetches an object given its ID"
    entities(
        "Defines which locales to query for"
        locales: [Locale!],
        "The where parameters to query components"
        where: [EntityWhereInput!]!
    ): [Entity!]
    "Retrieve a single model1"
    model1(
        """

        Defines which locales should be returned.

        Note that `Model1` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: Model1WhereUniqueInput!
    ): Model1
    "Retrieve document version"
    model1Version(where: VersionWhereInput!): DocumentVersion
    "Retrieve a single model2"
    model2(
        """

        Defines which locales should be returned.

        Note that `Model2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: Model2WhereUniqueInput!
    ): Model2
    "Retrieve document version"
    model2Version(where: VersionWhereInput!): DocumentVersion
    "Retrieve a single model3"
    model3(
        """

        Defines which locales should be returned.

        Note that `Model3` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: Model3WhereUniqueInput!
    ): Model3
    "Retrieve document version"
    model3Version(where: VersionWhereInput!): DocumentVersion
    "Retrieve multiple models1"
    models1(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Model1` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: Model1OrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: Model1WhereInput
    ): [Model1!]!
    "Retrieve multiple models1 using the Relay connection interface"
    models1Connection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Model1` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: Model1OrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: Model1WhereInput
    ): Model1Connection!
    "Retrieve multiple models2"
    models2(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Model2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: Model2OrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: Model2WhereInput
    ): [Model2!]!
    "Retrieve multiple models2 using the Relay connection interface"
    models2Connection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Model2` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: Model2OrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: Model2WhereInput
    ): Model2Connection!
    "Retrieve multiple models3"
    models3(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Model3` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: Model3OrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: Model3WhereInput
    ): [Model3!]!
    "Retrieve multiple models3 using the Relay connection interface"
    models3Connection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `Model3` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: Model3OrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: Model3WhereInput
    ): Model3Connection!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!,
        """

        Defines which locales should be returned.

        Note that `Node` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED
    ): Node
    "Retrieve a single scheduledOperation"
    scheduledOperation(
        """

        Defines which locales should be returned.

        Note that `ScheduledOperation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ScheduledOperationWhereUniqueInput!
    ): ScheduledOperation
    "Retrieve multiple scheduledOperations"
    scheduledOperations(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledOperation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledOperationOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "Retrieve multiple scheduledOperations using the Relay connection interface"
    scheduledOperationsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledOperation` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledOperationOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledOperationWhereInput
    ): ScheduledOperationConnection!
    "Retrieve a single scheduledRelease"
    scheduledRelease(
        """

        Defines which locales should be returned.

        Note that `ScheduledRelease` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: ScheduledReleaseWhereUniqueInput!
    ): ScheduledRelease
    "Retrieve multiple scheduledReleases"
    scheduledReleases(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledRelease` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledReleaseOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledReleaseWhereInput
    ): [ScheduledRelease!]!
    "Retrieve multiple scheduledReleases using the Relay connection interface"
    scheduledReleasesConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `ScheduledRelease` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: ScheduledReleaseOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: ScheduledReleaseWhereInput
    ): ScheduledReleaseConnection!
    "Retrieve a single user"
    user(
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: UserWhereUniqueInput!
    ): User
    "Retrieve multiple users"
    users(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: UserOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: UserWhereInput
    ): [User!]!
    "Retrieve multiple users using the Relay connection interface"
    usersConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        """

        Defines which locales should be returned.

        Note that `User` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument may be overwritten by another locales definition in a relational child field, this will effectively use the overwritten argument for the affected query's subtree.
        """
        locales: [Locale!]! = [en],
        orderBy: UserOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: UserWhereInput
    ): UserConnection!
}

"Representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
type RGBA {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

"Custom type representing a rich text value comprising of raw rich text ast, html, markdown and text values"
type RichText {
    "Returns HTMl representation"
    html: String!
    "Returns Markdown representation"
    markdown: String!
    "Returns AST representation"
    raw: RichTextAST!
    "Returns plain-text contents of RichText"
    text: String!
}

"Scheduled Operation system model"
type ScheduledOperation implements Entity & Node {
    affectedDocuments(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `affectedDocuments` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `affectedDocuments` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        skip: Int
    ): [ScheduledOperationAffectedDocument!]!
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Operation description"
    description: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [ScheduledOperation!]!
    "Operation error message"
    errorMessage: String
    "The unique identifier"
    id: ID!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Raw operation payload including all details, this field is subject to change"
    rawPayload: Json!
    "The release this operation is scheduled for"
    release(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `release` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `release` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): ScheduledRelease
    "System stage field"
    stage: Stage!
    "operation Status"
    status: ScheduledOperationStatus!
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ScheduledOperationConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ScheduledOperationEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ScheduledOperationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ScheduledOperation!
}

"Scheduled Release system model"
type ScheduledRelease implements Entity & Node {
    "The time the document was created"
    createdAt: DateTime!
    "User that created this document"
    createdBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `createdBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Release description"
    description: String
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [ScheduledRelease!]!
    "Release error message"
    errorMessage: String
    "The unique identifier"
    id: ID!
    "Whether scheduled release should be run"
    isActive: Boolean!
    "Whether scheduled release is implicit"
    isImplicit: Boolean!
    "Operations to run with this release"
    operations(
        after: String,
        before: String,
        first: Int,
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `operations` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        last: Int,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `operations` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!],
        orderBy: ScheduledOperationOrderByInput,
        skip: Int,
        where: ScheduledOperationWhereInput
    ): [ScheduledOperation!]!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "User that last published this document"
    publishedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `publishedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
    "Release date and time"
    releaseAt: DateTime
    "System stage field"
    stage: Stage!
    "Release Status"
    status: ScheduledReleaseStatus!
    "Release Title"
    title: String
    "The time the document was updated"
    updatedAt: DateTime!
    "User that last updated this document"
    updatedBy(
        """

        Sets the locale of the resolved parent document as the only locale in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locale will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will affect any existing locale filtering defined in the query's tree for the subtree.
        """
        forceParentLocale: Boolean,
        """

        Allows to optionally override locale filtering behaviour in the query's subtree.

        Note that `updatedBy` is a model without localized fields and will not be affected directly by this argument, however the locales will be passed on to any relational fields in the query's subtree for filtering.
        For related models with localized fields in the query's subtree, the first locale matching the provided list of locales will be returned, entries with non matching locales will be filtered out.

        This argument will overwrite any existing locale filtering defined in the query's tree for the subtree.
        """
        locales: [Locale!]
    ): User
}

"A connection to a list of items."
type ScheduledReleaseConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [ScheduledReleaseEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ScheduledReleaseEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ScheduledRelease!
}

"User system model"
type User implements Entity & Node {
    "The time the document was created"
    createdAt: DateTime!
    "Get the document in other stages"
    documentInStages(
        "Decides if the current stage should be included or not"
        includeCurrent: Boolean! = false,
        "Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree"
        inheritLocale: Boolean! = false,
        "Potential stages that should be returned"
        stages: [Stage!]! = [DRAFT, PUBLISHED]
    ): [User!]!
    "The unique identifier"
    id: ID!
    "Flag to determine if user is active or not"
    isActive: Boolean!
    "User Kind. Can be either MEMBER, PAT or PUBLIC"
    kind: UserKind!
    "The username"
    name: String!
    "Profile Picture url"
    picture: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
}

"A connection to a list of items."
type UserConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [UserEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type Version {
    createdAt: DateTime!
    id: ID!
    revision: Int!
    stage: Stage!
}

enum AssetOrderByInput {
    createdAt_ASC
    createdAt_DESC
    fileName_ASC
    fileName_DESC
    handle_ASC
    handle_DESC
    height_ASC
    height_DESC
    id_ASC
    id_DESC
    mimeType_ASC
    mimeType_DESC
    publishedAt_ASC
    publishedAt_DESC
    size_ASC
    size_DESC
    updatedAt_ASC
    updatedAt_DESC
    width_ASC
    width_DESC
}

"System Asset Upload Status"
enum AssetUploadStatus {
    ASSET_CREATE_PENDING
    ASSET_ERROR_UPLOAD
    ASSET_UPDATE_PENDING
    ASSET_UPLOAD_COMPLETE
}

enum ComponentModel1OrderByInput {
    id_ASC
    id_DESC
    title_ASC
    title_DESC
}

enum ComponentModel2OrderByInput {
    id_ASC
    id_DESC
    title_ASC
    title_DESC
}

enum CustomEnumeration {
    bar
    baz
    foo
}

enum DocumentFileTypes {
    "Automatically selects the best format for the image based on the browser's capabilities."
    autoImage
    avif
    bmp
    gif
    heic
    jpg
    png
    svg
    tiff
    webp
}

"This enumeration holds all typenames that implement the Entity interface. Components and models implement the Entity interface."
enum EntityTypeName {
    "Asset system model"
    Asset
    ComponentModel1
    ComponentModel2
    "Model with different fields"
    Model1
    "Model with component and reference fields"
    Model2
    "Model with list fields"
    Model3
    "Scheduled Operation system model"
    ScheduledOperation
    "Scheduled Release system model"
    ScheduledRelease
    "User system model"
    User
}

enum ImageFit {
    "Resizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio."
    clip
    "Resizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries."
    crop
    "Resizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size."
    max
    "Resizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method."
    scale
}

"Locale system enumeration"
enum Locale {
    "System locale"
    en
}

enum Model1OrderByInput {
    booleanField_ASC
    booleanField_DESC
    createdAt_ASC
    createdAt_DESC
    dateField_ASC
    dateField_DESC
    datetimeField_ASC
    datetimeField_DESC
    enumerationField_ASC
    enumerationField_DESC
    floatField_ASC
    floatField_DESC
    id_ASC
    id_DESC
    integerField_ASC
    integerField_DESC
    markdownField_ASC
    markdownField_DESC
    multilineField_ASC
    multilineField_DESC
    publishedAt_ASC
    publishedAt_DESC
    slug_ASC
    slug_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum Model2OrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum Model3OrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    listOfEnums_ASC
    listOfEnums_DESC
    listOfFloats_ASC
    listOfFloats_DESC
    listOfIntegers_ASC
    listOfIntegers_DESC
    listOfMultiline_ASC
    listOfMultiline_DESC
    listOfStrings_ASC
    listOfStrings_DESC
    publishedAt_ASC
    publishedAt_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum ScheduledOperationOrderByInput {
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    errorMessage_ASC
    errorMessage_DESC
    id_ASC
    id_DESC
    publishedAt_ASC
    publishedAt_DESC
    status_ASC
    status_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"System Scheduled Operation Status"
enum ScheduledOperationStatus {
    CANCELED
    COMPLETED
    FAILED
    IN_PROGRESS
    PENDING
}

enum ScheduledReleaseOrderByInput {
    createdAt_ASC
    createdAt_DESC
    description_ASC
    description_DESC
    errorMessage_ASC
    errorMessage_DESC
    id_ASC
    id_DESC
    isActive_ASC
    isActive_DESC
    isImplicit_ASC
    isImplicit_DESC
    publishedAt_ASC
    publishedAt_DESC
    releaseAt_ASC
    releaseAt_DESC
    status_ASC
    status_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"System Scheduled Release Status"
enum ScheduledReleaseStatus {
    COMPLETED
    FAILED
    IN_PROGRESS
    PENDING
}

"Stage system enumeration"
enum Stage {
    "The Draft is the default stage for all your content."
    DRAFT
    "The Published stage is where you can publish your content to."
    PUBLISHED
}

enum SystemDateTimeFieldVariation {
    BASE
    COMBINED
    LOCALIZATION
}

"System User Kind"
enum UserKind {
    APP_TOKEN
    MEMBER
    PAT
    PUBLIC
    WEBHOOK
}

enum UserOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    isActive_ASC
    isActive_DESC
    kind_ASC
    kind_DESC
    name_ASC
    name_DESC
    picture_ASC
    picture_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum _FilterKind {
    AND
    NOT
    OR
    contains
    contains_all
    contains_none
    contains_some
    ends_with
    eq
    eq_not
    gt
    gte
    in
    json_path_exists
    json_value_recursive
    lt
    lte
    not_contains
    not_ends_with
    not_in
    not_starts_with
    relational_every
    relational_none
    relational_single
    relational_some
    search
    starts_with
    union_empty
    union_every
    union_none
    union_single
    union_some
}

enum _MutationInputFieldKind {
    enum
    relation
    richText
    richTextWithEmbeds
    scalar
    union
    virtual
}

enum _MutationKind {
    create
    delete
    deleteMany
    publish
    publishMany
    schedulePublish
    scheduleUnpublish
    unpublish
    unpublishMany
    update
    updateMany
    upsert
}

enum _OrderDirection {
    asc
    desc
}

enum _RelationInputCardinality {
    many
    one
}

enum _RelationInputKind {
    create
    update
}

enum _RelationKind {
    regular
    union
}

enum _SystemDateTimeFieldVariation {
    base
    combined
    localization
}

"A date string, such as 2007-12-03 (YYYY-MM-DD), compliant with ISO 8601 standard for representation of dates using the Gregorian calendar."
scalar Date

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the date-timeformat outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representationof dates and times using the Gregorian calendar."
scalar DateTime

scalar Hex

"Raw JSON value"
scalar Json

"The Long scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar RGBAHue

scalar RGBATransparency

"Slate-compatible RichText AST"
scalar RichTextAST

input AssetConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: AssetWhereUniqueInput!
}

input AssetCreateInput {
    assetFieldModel1: Model1CreateManyInlineInput
    createdAt: DateTime
    fileName: String
    listOfAssetsModel3: Model3CreateManyInlineInput
    "Inline mutations for managing document localizations excluding the default locale"
    localizations: AssetCreateLocalizationsInput
    updatedAt: DateTime
    "Optionally the system can upload a file for you, for that you need to provide a publicly accessible url"
    uploadUrl: String
}

input AssetCreateLocalizationDataInput {
    createdAt: DateTime
    fileName: String
    updatedAt: DateTime
    "Optionally the system can upload a file for you, for that you need to provide a publicly accessible url"
    uploadUrl: String
}

input AssetCreateLocalizationInput {
    "Localization input"
    data: AssetCreateLocalizationDataInput!
    locale: Locale!
}

input AssetCreateLocalizationsInput {
    "Create localizations for the newly-created document"
    create: [AssetCreateLocalizationInput!]
}

input AssetCreateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetWhereUniqueInput!]
    "Create and connect multiple existing Asset documents"
    create: [AssetCreateInput!]
}

input AssetCreateOneInlineInput {
    "Connect one existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
}

"Identifies documents"
input AssetManyWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    assetFieldModel1_every: Model1WhereInput
    assetFieldModel1_none: Model1WhereInput
    assetFieldModel1_some: Model1WhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    documentInStages_every: AssetWhereStageInput
    documentInStages_none: AssetWhereStageInput
    documentInStages_some: AssetWhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    listOfAssetsModel3_every: Model3WhereInput
    listOfAssetsModel3_none: Model3WhereInput
    listOfAssetsModel3_some: Model3WhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
    upload: AssetUploadWhereInput
}

"Identifies documents"
input AssetSingleRelationWhereInput {
    "Logical AND on all given filters."
    AND: [AssetSingleRelationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetSingleRelationWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetSingleRelationWhereInput!]
    upload: AssetUploadWhereInput
}

"Transformations for Assets"
input AssetTransformationInput {
    document: DocumentTransformationInput
    image: ImageTransformationInput
    "Pass true if you want to validate the passed transformation parameters"
    validateOptions: Boolean = false
}

input AssetUpdateInput {
    assetFieldModel1: Model1UpdateManyInlineInput
    fileName: String
    listOfAssetsModel3: Model3UpdateManyInlineInput
    "Manage document localizations"
    localizations: AssetUpdateLocalizationsInput
    "Use this to define if its a reupload for the asset"
    reUpload: Boolean
    "Optionally the system can upload a file for you, for that you need to provide a publicly accessible url"
    uploadUrl: String
}

input AssetUpdateLocalizationDataInput {
    fileName: String
    "Use this to define if its a reupload for the asset"
    reUpload: Boolean
    "Optionally the system can upload a file for you, for that you need to provide a publicly accessible url"
    uploadUrl: String
}

input AssetUpdateLocalizationInput {
    data: AssetUpdateLocalizationDataInput!
    locale: Locale!
}

input AssetUpdateLocalizationsInput {
    "Localizations to create"
    create: [AssetCreateLocalizationInput!]
    "Localizations to delete"
    delete: [Locale!]
    "Localizations to update"
    update: [AssetUpdateLocalizationInput!]
    upsert: [AssetUpsertLocalizationInput!]
}

input AssetUpdateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetConnectInput!]
    "Create and connect multiple Asset documents"
    create: [AssetCreateInput!]
    "Delete multiple Asset documents"
    delete: [AssetWhereUniqueInput!]
    "Disconnect multiple Asset documents"
    disconnect: [AssetWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Asset documents"
    set: [AssetWhereUniqueInput!]
    "Update multiple Asset documents"
    update: [AssetUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Asset documents"
    upsert: [AssetUpsertWithNestedWhereUniqueInput!]
}

input AssetUpdateManyInput {
    "No fields in updateMany data input"
    _: String
}

input AssetUpdateManyWithNestedWhereInput {
    "Update many input"
    data: AssetUpdateManyInput!
    "Document search"
    where: AssetWhereInput!
}

input AssetUpdateOneInlineInput {
    "Connect existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
    "Delete currently connected Asset document"
    delete: Boolean
    "Disconnect currently connected Asset document"
    disconnect: Boolean
    "Update single Asset document"
    update: AssetUpdateWithNestedWhereUniqueInput
    "Upsert single Asset document"
    upsert: AssetUpsertWithNestedWhereUniqueInput
}

input AssetUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: AssetUpdateInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

"Identifies documents"
input AssetUploadWhereInput {
    "Logical AND on all given filters."
    AND: [AssetUploadWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetUploadWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetUploadWhereInput!]
    expiresAt: DateTime
    "All values greater than the given value."
    expiresAt_gt: DateTime
    "All values greater than or equal the given value."
    expiresAt_gte: DateTime
    "All values that are contained in given list."
    expiresAt_in: [DateTime]
    "All values less than the given value."
    expiresAt_lt: DateTime
    "All values less than or equal the given value."
    expiresAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    expiresAt_not: DateTime
    "All values that are not contained in given list."
    expiresAt_not_in: [DateTime]
    status: AssetUploadStatus
    "All values that are contained in given list."
    status_in: [AssetUploadStatus]
    "Any other value that exists and is not equal to the given value."
    status_not: AssetUploadStatus
    "All values that are not contained in given list."
    status_not_in: [AssetUploadStatus]
}

"Identifies documents"
input AssetUploadWhereStageInput {
    "Logical AND on all given filters."
    AND: [AssetUploadWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetUploadWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetUploadWhereInput!]
    expiresAt: DateTime
    "All values greater than the given value."
    expiresAt_gt: DateTime
    "All values greater than or equal the given value."
    expiresAt_gte: DateTime
    "All values that are contained in given list."
    expiresAt_in: [DateTime]
    "All values less than the given value."
    expiresAt_lt: DateTime
    "All values less than or equal the given value."
    expiresAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    expiresAt_not: DateTime
    "All values that are not contained in given list."
    expiresAt_not_in: [DateTime]
    status: AssetUploadStatus
    "All values that are contained in given list."
    status_in: [AssetUploadStatus]
    "Any other value that exists and is not equal to the given value."
    status_not: AssetUploadStatus
    "All values that are not contained in given list."
    status_not_in: [AssetUploadStatus]
}

input AssetUpsertInput {
    "Create document if it didn't exist"
    create: AssetCreateInput!
    "Update document if it exists"
    update: AssetUpdateInput!
}

input AssetUpsertLocalizationInput {
    create: AssetCreateLocalizationDataInput!
    locale: Locale!
    update: AssetUpdateLocalizationDataInput!
}

input AssetUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: AssetUpsertInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

"This contains a set of filters that can be used to compare values internally"
input AssetWhereComparatorInput {
    "This field can be used to request to check if the entry is outdated by internal comparison"
    outdated_to: Boolean
}

"Identifies documents"
input AssetWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    assetFieldModel1_every: Model1WhereInput
    assetFieldModel1_none: Model1WhereInput
    assetFieldModel1_some: Model1WhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    documentInStages_every: AssetWhereStageInput
    documentInStages_none: AssetWhereStageInput
    documentInStages_some: AssetWhereStageInput
    fileName: String
    "All values containing the given string."
    fileName_contains: String
    "All values ending with the given string."
    fileName_ends_with: String
    "All values that are contained in given list."
    fileName_in: [String]
    "Any other value that exists and is not equal to the given value."
    fileName_not: String
    "All values not containing the given string."
    fileName_not_contains: String
    "All values not ending with the given string"
    fileName_not_ends_with: String
    "All values that are not contained in given list."
    fileName_not_in: [String]
    "All values not starting with the given string."
    fileName_not_starts_with: String
    "All values starting with the given string."
    fileName_starts_with: String
    handle: String
    "All values containing the given string."
    handle_contains: String
    "All values ending with the given string."
    handle_ends_with: String
    "All values that are contained in given list."
    handle_in: [String]
    "Any other value that exists and is not equal to the given value."
    handle_not: String
    "All values not containing the given string."
    handle_not_contains: String
    "All values not ending with the given string"
    handle_not_ends_with: String
    "All values that are not contained in given list."
    handle_not_in: [String]
    "All values not starting with the given string."
    handle_not_starts_with: String
    "All values starting with the given string."
    handle_starts_with: String
    height: Float
    "All values greater than the given value."
    height_gt: Float
    "All values greater than or equal the given value."
    height_gte: Float
    "All values that are contained in given list."
    height_in: [Float]
    "All values less than the given value."
    height_lt: Float
    "All values less than or equal the given value."
    height_lte: Float
    "Any other value that exists and is not equal to the given value."
    height_not: Float
    "All values that are not contained in given list."
    height_not_in: [Float]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    listOfAssetsModel3_every: Model3WhereInput
    listOfAssetsModel3_none: Model3WhereInput
    listOfAssetsModel3_some: Model3WhereInput
    mimeType: String
    "All values containing the given string."
    mimeType_contains: String
    "All values ending with the given string."
    mimeType_ends_with: String
    "All values that are contained in given list."
    mimeType_in: [String]
    "Any other value that exists and is not equal to the given value."
    mimeType_not: String
    "All values not containing the given string."
    mimeType_not_contains: String
    "All values not ending with the given string"
    mimeType_not_ends_with: String
    "All values that are not contained in given list."
    mimeType_not_in: [String]
    "All values not starting with the given string."
    mimeType_not_starts_with: String
    "All values starting with the given string."
    mimeType_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    size: Float
    "All values greater than the given value."
    size_gt: Float
    "All values greater than or equal the given value."
    size_gte: Float
    "All values that are contained in given list."
    size_in: [Float]
    "All values less than the given value."
    size_lt: Float
    "All values less than or equal the given value."
    size_lte: Float
    "Any other value that exists and is not equal to the given value."
    size_not: Float
    "All values that are not contained in given list."
    size_not_in: [Float]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
    upload: AssetUploadWhereInput
    width: Float
    "All values greater than the given value."
    width_gt: Float
    "All values greater than or equal the given value."
    width_gte: Float
    "All values that are contained in given list."
    width_in: [Float]
    "All values less than the given value."
    width_lt: Float
    "All values less than or equal the given value."
    width_lte: Float
    "Any other value that exists and is not equal to the given value."
    width_not: Float
    "All values that are not contained in given list."
    width_not_in: [Float]
}

"The document in stages filter allows specifying a stage entry to cross compare the same document between different stages"
input AssetWhereStageInput {
    "Logical AND on all given filters."
    AND: [AssetWhereStageInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereStageInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereStageInput!]
    "This field contains fields which can be set as true or false to specify an internal comparison"
    compareWithParent: AssetWhereComparatorInput
    "Specify the stage to compare with"
    stage: Stage
}

"References Asset record uniquely"
input AssetWhereUniqueInput {
    id: ID
}

"Accepts either HEX or RGBA color value. At least one of hex or rgba value should be passed. If both are passed RGBA is used."
input ColorInput {
    hex: Hex
    rgba: RGBAInput
}

input ComponentModel1ConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ComponentModel1WhereUniqueInput!
}

input ComponentModel1CreateInput {
    multiComponentField: ComponentModel1multiComponentFieldUnionCreateOneInlineInput
    singleComponentField: ComponentModel1CreateOneInlineInput
    singleToOneReference: Model2CreateOneInlineInput
    title: String
}

input ComponentModel1CreateManyInlineInput {
    "Create and connect multiple existing ComponentModel1 documents"
    create: [ComponentModel1CreateInput!]
}

input ComponentModel1CreateOneInlineInput {
    "Create and connect one ComponentModel1 document"
    create: ComponentModel1CreateInput
}

input ComponentModel1CreateWithPositionInput {
    "Document to create"
    data: ComponentModel1CreateInput!
    "Position in the list of existing component instances, will default to appending at the end of list"
    position: ConnectPositionInput
}

"Identifies documents"
input ComponentModel1ManyWhereInput {
    "Logical AND on all given filters."
    AND: [ComponentModel1WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ComponentModel1WhereInput!]
    "Logical OR on all given filters."
    OR: [ComponentModel1WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    "All values in which the modular component is connected to the given models"
    multiComponentField: ComponentModel1multiComponentFieldUnionWhereInput
    "All values in which the union is empty."
    multiComponentField_empty: Boolean
    singleComponentField: ComponentModel1WhereInput
    singleToOneReference: Model2WhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
}

input ComponentModel1ParentConnectInput {
    ComponentModel1: ComponentModel1ConnectInput
    Model2: Model2ConnectInput
    Model3: Model3ConnectInput
}

input ComponentModel1ParentCreateInput {
    ComponentModel1: ComponentModel1CreateInput
    Model2: Model2CreateInput
    Model3: Model3CreateInput
}

input ComponentModel1ParentCreateManyInlineInput {
    "Connect multiple existing ComponentModel1Parent documents"
    connect: [ComponentModel1ParentWhereUniqueInput!]
    "Create and connect multiple existing ComponentModel1Parent documents"
    create: [ComponentModel1ParentCreateInput!]
}

input ComponentModel1ParentCreateOneInlineInput {
    "Connect one existing ComponentModel1Parent document"
    connect: ComponentModel1ParentWhereUniqueInput
    "Create and connect one ComponentModel1Parent document"
    create: ComponentModel1ParentCreateInput
}

input ComponentModel1ParentUpdateInput {
    ComponentModel1: ComponentModel1UpdateInput
    Model2: Model2UpdateInput
    Model3: Model3UpdateInput
}

input ComponentModel1ParentUpdateManyInlineInput {
    "Connect multiple existing ComponentModel1Parent documents"
    connect: [ComponentModel1ParentConnectInput!]
    "Create and connect multiple ComponentModel1Parent documents"
    create: [ComponentModel1ParentCreateInput!]
    "Delete multiple ComponentModel1Parent documents"
    delete: [ComponentModel1ParentWhereUniqueInput!]
    "Disconnect multiple ComponentModel1Parent documents"
    disconnect: [ComponentModel1ParentWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ComponentModel1Parent documents"
    set: [ComponentModel1ParentWhereUniqueInput!]
    "Update multiple ComponentModel1Parent documents"
    update: [ComponentModel1ParentUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ComponentModel1Parent documents"
    upsert: [ComponentModel1ParentUpsertWithNestedWhereUniqueInput!]
}

input ComponentModel1ParentUpdateManyWithNestedWhereInput {
    ComponentModel1: ComponentModel1UpdateManyWithNestedWhereInput
    Model2: Model2UpdateManyWithNestedWhereInput
    Model3: Model3UpdateManyWithNestedWhereInput
}

input ComponentModel1ParentUpdateOneInlineInput {
    "Connect existing ComponentModel1Parent document"
    connect: ComponentModel1ParentWhereUniqueInput
    "Create and connect one ComponentModel1Parent document"
    create: ComponentModel1ParentCreateInput
    "Delete currently connected ComponentModel1Parent document"
    delete: Boolean
    "Disconnect currently connected ComponentModel1Parent document"
    disconnect: Boolean
    "Update single ComponentModel1Parent document"
    update: ComponentModel1ParentUpdateWithNestedWhereUniqueInput
    "Upsert single ComponentModel1Parent document"
    upsert: ComponentModel1ParentUpsertWithNestedWhereUniqueInput
}

input ComponentModel1ParentUpdateWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueInput
    Model2: Model2UpdateWithNestedWhereUniqueInput
    Model3: Model3UpdateWithNestedWhereUniqueInput
}

input ComponentModel1ParentUpsertWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueInput
    Model2: Model2UpsertWithNestedWhereUniqueInput
    Model3: Model3UpsertWithNestedWhereUniqueInput
}

input ComponentModel1ParentWhereInput {
    ComponentModel1: ComponentModel1WhereInput
    Model2: Model2WhereInput
    Model3: Model3WhereInput
}

input ComponentModel1ParentWhereUniqueInput {
    ComponentModel1: ComponentModel1WhereUniqueInput
    Model2: Model2WhereUniqueInput
    Model3: Model3WhereUniqueInput
}

input ComponentModel1UpdateInput {
    multiComponentField: ComponentModel1multiComponentFieldUnionUpdateOneInlineInput
    singleComponentField: ComponentModel1UpdateOneInlineInput
    singleToOneReference: Model2UpdateOneInlineInput
    title: String
}

input ComponentModel1UpdateManyInlineInput {
    "Create and connect multiple ComponentModel1 component instances"
    create: [ComponentModel1CreateWithPositionInput!]
    "Delete multiple ComponentModel1 documents"
    delete: [ComponentModel1WhereUniqueInput!]
    "Update multiple ComponentModel1 component instances"
    update: [ComponentModel1UpdateWithNestedWhereUniqueAndPositionInput!]
    "Upsert multiple ComponentModel1 component instances"
    upsert: [ComponentModel1UpsertWithNestedWhereUniqueAndPositionInput!]
}

input ComponentModel1UpdateManyInput {
    title: String
}

input ComponentModel1UpdateManyWithNestedWhereInput {
    "Update many input"
    data: ComponentModel1UpdateManyInput!
    "Document search"
    where: ComponentModel1WhereInput!
}

input ComponentModel1UpdateOneInlineInput {
    "Create and connect one ComponentModel1 document"
    create: ComponentModel1CreateInput
    "Delete currently connected ComponentModel1 document"
    delete: Boolean
    "Update single ComponentModel1 document"
    update: ComponentModel1UpdateWithNestedWhereUniqueInput
    "Upsert single ComponentModel1 document"
    upsert: ComponentModel1UpsertWithNestedWhereUniqueInput
}

input ComponentModel1UpdateWithNestedWhereUniqueAndPositionInput {
    "Document to update"
    data: ComponentModel1UpdateInput
    "Position in the list of existing component instances, will default to appending at the end of list"
    position: ConnectPositionInput
    "Unique component instance search"
    where: ComponentModel1WhereUniqueInput!
}

input ComponentModel1UpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ComponentModel1UpdateInput!
    "Unique document search"
    where: ComponentModel1WhereUniqueInput!
}

input ComponentModel1UpsertInput {
    "Create document if it didn't exist"
    create: ComponentModel1CreateInput!
    "Update document if it exists"
    update: ComponentModel1UpdateInput!
}

input ComponentModel1UpsertWithNestedWhereUniqueAndPositionInput {
    "Document to upsert"
    data: ComponentModel1UpsertInput
    "Position in the list of existing component instances, will default to appending at the end of list"
    position: ConnectPositionInput
    "Unique component instance search"
    where: ComponentModel1WhereUniqueInput!
}

input ComponentModel1UpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ComponentModel1UpsertInput!
    "Unique document search"
    where: ComponentModel1WhereUniqueInput!
}

"Identifies documents"
input ComponentModel1WhereInput {
    "Logical AND on all given filters."
    AND: [ComponentModel1WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ComponentModel1WhereInput!]
    "Logical OR on all given filters."
    OR: [ComponentModel1WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    "All values in which the modular component is connected to the given models"
    multiComponentField: ComponentModel1multiComponentFieldUnionWhereInput
    "All values in which the union is empty."
    multiComponentField_empty: Boolean
    singleComponentField: ComponentModel1WhereInput
    singleToOneReference: Model2WhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
}

"References ComponentModel1 record uniquely"
input ComponentModel1WhereUniqueInput {
    id: ID
}

input ComponentModel1multiComponentFieldUnionConnectInput {
    ComponentModel1: ComponentModel1ConnectInput
    ComponentModel2: ComponentModel2ConnectInput
}

input ComponentModel1multiComponentFieldUnionCreateInput {
    ComponentModel1: ComponentModel1CreateInput
    ComponentModel2: ComponentModel2CreateInput
}

input ComponentModel1multiComponentFieldUnionCreateManyInlineInput {
    "Create and connect multiple existing ComponentModel1multiComponentFieldUnion documents"
    create: [ComponentModel1multiComponentFieldUnionCreateInput!]
}

input ComponentModel1multiComponentFieldUnionCreateOneInlineInput {
    "Create and connect one ComponentModel1multiComponentFieldUnion document"
    create: ComponentModel1multiComponentFieldUnionCreateInput
}

input ComponentModel1multiComponentFieldUnionCreateWithPositionInput {
    ComponentModel1: ComponentModel1CreateWithPositionInput
    ComponentModel2: ComponentModel2CreateWithPositionInput
}

input ComponentModel1multiComponentFieldUnionUpdateInput {
    ComponentModel1: ComponentModel1UpdateInput
    ComponentModel2: ComponentModel2UpdateInput
}

input ComponentModel1multiComponentFieldUnionUpdateManyInlineInput {
    "Create and connect multiple ComponentModel1multiComponentFieldUnion component instances"
    create: [ComponentModel1multiComponentFieldUnionCreateWithPositionInput!]
    "Delete multiple ComponentModel1multiComponentFieldUnion documents"
    delete: [ComponentModel1multiComponentFieldUnionWhereUniqueInput!]
    "Update multiple ComponentModel1multiComponentFieldUnion component instances"
    update: [ComponentModel1multiComponentFieldUnionUpdateWithNestedWhereUniqueAndPositionInput!]
    "Upsert multiple ComponentModel1multiComponentFieldUnion component instances"
    upsert: [ComponentModel1multiComponentFieldUnionUpsertWithNestedWhereUniqueAndPositionInput!]
}

input ComponentModel1multiComponentFieldUnionUpdateManyWithNestedWhereInput {
    ComponentModel1: ComponentModel1UpdateManyWithNestedWhereInput
    ComponentModel2: ComponentModel2UpdateManyWithNestedWhereInput
}

input ComponentModel1multiComponentFieldUnionUpdateOneInlineInput {
    "Create and connect one ComponentModel1multiComponentFieldUnion document"
    create: ComponentModel1multiComponentFieldUnionCreateInput
    "Delete currently connected ComponentModel1multiComponentFieldUnion document"
    delete: Boolean
    "Update single ComponentModel1multiComponentFieldUnion document"
    update: ComponentModel1multiComponentFieldUnionUpdateWithNestedWhereUniqueInput
    "Upsert single ComponentModel1multiComponentFieldUnion document"
    upsert: ComponentModel1multiComponentFieldUnionUpsertWithNestedWhereUniqueInput
}

input ComponentModel1multiComponentFieldUnionUpdateWithNestedWhereUniqueAndPositionInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueAndPositionInput
    ComponentModel2: ComponentModel2UpdateWithNestedWhereUniqueAndPositionInput
}

input ComponentModel1multiComponentFieldUnionUpdateWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueInput
    ComponentModel2: ComponentModel2UpdateWithNestedWhereUniqueInput
}

input ComponentModel1multiComponentFieldUnionUpsertWithNestedWhereUniqueAndPositionInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueAndPositionInput
    ComponentModel2: ComponentModel2UpsertWithNestedWhereUniqueAndPositionInput
}

input ComponentModel1multiComponentFieldUnionUpsertWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueInput
    ComponentModel2: ComponentModel2UpsertWithNestedWhereUniqueInput
}

input ComponentModel1multiComponentFieldUnionWhereInput {
    ComponentModel1: ComponentModel1WhereInput
    ComponentModel2: ComponentModel2WhereInput
}

input ComponentModel1multiComponentFieldUnionWhereUniqueInput {
    ComponentModel1: ComponentModel1WhereUniqueInput
    ComponentModel2: ComponentModel2WhereUniqueInput
}

input ComponentModel2ConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ComponentModel2WhereUniqueInput!
}

input ComponentModel2CreateInput {
    title: String
}

input ComponentModel2CreateManyInlineInput {
    "Create and connect multiple existing ComponentModel2 documents"
    create: [ComponentModel2CreateInput!]
}

input ComponentModel2CreateOneInlineInput {
    "Create and connect one ComponentModel2 document"
    create: ComponentModel2CreateInput
}

input ComponentModel2CreateWithPositionInput {
    "Document to create"
    data: ComponentModel2CreateInput!
    "Position in the list of existing component instances, will default to appending at the end of list"
    position: ConnectPositionInput
}

"Identifies documents"
input ComponentModel2ManyWhereInput {
    "Logical AND on all given filters."
    AND: [ComponentModel2WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ComponentModel2WhereInput!]
    "Logical OR on all given filters."
    OR: [ComponentModel2WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
}

input ComponentModel2ParentConnectInput {
    ComponentModel1: ComponentModel1ConnectInput
    Model2: Model2ConnectInput
    Model3: Model3ConnectInput
}

input ComponentModel2ParentCreateInput {
    ComponentModel1: ComponentModel1CreateInput
    Model2: Model2CreateInput
    Model3: Model3CreateInput
}

input ComponentModel2ParentCreateManyInlineInput {
    "Connect multiple existing ComponentModel2Parent documents"
    connect: [ComponentModel2ParentWhereUniqueInput!]
    "Create and connect multiple existing ComponentModel2Parent documents"
    create: [ComponentModel2ParentCreateInput!]
}

input ComponentModel2ParentCreateOneInlineInput {
    "Connect one existing ComponentModel2Parent document"
    connect: ComponentModel2ParentWhereUniqueInput
    "Create and connect one ComponentModel2Parent document"
    create: ComponentModel2ParentCreateInput
}

input ComponentModel2ParentUpdateInput {
    ComponentModel1: ComponentModel1UpdateInput
    Model2: Model2UpdateInput
    Model3: Model3UpdateInput
}

input ComponentModel2ParentUpdateManyInlineInput {
    "Connect multiple existing ComponentModel2Parent documents"
    connect: [ComponentModel2ParentConnectInput!]
    "Create and connect multiple ComponentModel2Parent documents"
    create: [ComponentModel2ParentCreateInput!]
    "Delete multiple ComponentModel2Parent documents"
    delete: [ComponentModel2ParentWhereUniqueInput!]
    "Disconnect multiple ComponentModel2Parent documents"
    disconnect: [ComponentModel2ParentWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ComponentModel2Parent documents"
    set: [ComponentModel2ParentWhereUniqueInput!]
    "Update multiple ComponentModel2Parent documents"
    update: [ComponentModel2ParentUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ComponentModel2Parent documents"
    upsert: [ComponentModel2ParentUpsertWithNestedWhereUniqueInput!]
}

input ComponentModel2ParentUpdateManyWithNestedWhereInput {
    ComponentModel1: ComponentModel1UpdateManyWithNestedWhereInput
    Model2: Model2UpdateManyWithNestedWhereInput
    Model3: Model3UpdateManyWithNestedWhereInput
}

input ComponentModel2ParentUpdateOneInlineInput {
    "Connect existing ComponentModel2Parent document"
    connect: ComponentModel2ParentWhereUniqueInput
    "Create and connect one ComponentModel2Parent document"
    create: ComponentModel2ParentCreateInput
    "Delete currently connected ComponentModel2Parent document"
    delete: Boolean
    "Disconnect currently connected ComponentModel2Parent document"
    disconnect: Boolean
    "Update single ComponentModel2Parent document"
    update: ComponentModel2ParentUpdateWithNestedWhereUniqueInput
    "Upsert single ComponentModel2Parent document"
    upsert: ComponentModel2ParentUpsertWithNestedWhereUniqueInput
}

input ComponentModel2ParentUpdateWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueInput
    Model2: Model2UpdateWithNestedWhereUniqueInput
    Model3: Model3UpdateWithNestedWhereUniqueInput
}

input ComponentModel2ParentUpsertWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueInput
    Model2: Model2UpsertWithNestedWhereUniqueInput
    Model3: Model3UpsertWithNestedWhereUniqueInput
}

input ComponentModel2ParentWhereInput {
    ComponentModel1: ComponentModel1WhereInput
    Model2: Model2WhereInput
    Model3: Model3WhereInput
}

input ComponentModel2ParentWhereUniqueInput {
    ComponentModel1: ComponentModel1WhereUniqueInput
    Model2: Model2WhereUniqueInput
    Model3: Model3WhereUniqueInput
}

input ComponentModel2UpdateInput {
    title: String
}

input ComponentModel2UpdateManyInlineInput {
    "Create and connect multiple ComponentModel2 component instances"
    create: [ComponentModel2CreateWithPositionInput!]
    "Delete multiple ComponentModel2 documents"
    delete: [ComponentModel2WhereUniqueInput!]
    "Update multiple ComponentModel2 component instances"
    update: [ComponentModel2UpdateWithNestedWhereUniqueAndPositionInput!]
    "Upsert multiple ComponentModel2 component instances"
    upsert: [ComponentModel2UpsertWithNestedWhereUniqueAndPositionInput!]
}

input ComponentModel2UpdateManyInput {
    title: String
}

input ComponentModel2UpdateManyWithNestedWhereInput {
    "Update many input"
    data: ComponentModel2UpdateManyInput!
    "Document search"
    where: ComponentModel2WhereInput!
}

input ComponentModel2UpdateOneInlineInput {
    "Create and connect one ComponentModel2 document"
    create: ComponentModel2CreateInput
    "Delete currently connected ComponentModel2 document"
    delete: Boolean
    "Update single ComponentModel2 document"
    update: ComponentModel2UpdateWithNestedWhereUniqueInput
    "Upsert single ComponentModel2 document"
    upsert: ComponentModel2UpsertWithNestedWhereUniqueInput
}

input ComponentModel2UpdateWithNestedWhereUniqueAndPositionInput {
    "Document to update"
    data: ComponentModel2UpdateInput
    "Position in the list of existing component instances, will default to appending at the end of list"
    position: ConnectPositionInput
    "Unique component instance search"
    where: ComponentModel2WhereUniqueInput!
}

input ComponentModel2UpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ComponentModel2UpdateInput!
    "Unique document search"
    where: ComponentModel2WhereUniqueInput!
}

input ComponentModel2UpsertInput {
    "Create document if it didn't exist"
    create: ComponentModel2CreateInput!
    "Update document if it exists"
    update: ComponentModel2UpdateInput!
}

input ComponentModel2UpsertWithNestedWhereUniqueAndPositionInput {
    "Document to upsert"
    data: ComponentModel2UpsertInput
    "Position in the list of existing component instances, will default to appending at the end of list"
    position: ConnectPositionInput
    "Unique component instance search"
    where: ComponentModel2WhereUniqueInput!
}

input ComponentModel2UpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ComponentModel2UpsertInput!
    "Unique document search"
    where: ComponentModel2WhereUniqueInput!
}

"Identifies documents"
input ComponentModel2WhereInput {
    "Logical AND on all given filters."
    AND: [ComponentModel2WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ComponentModel2WhereInput!]
    "Logical OR on all given filters."
    OR: [ComponentModel2WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
}

"References ComponentModel2 record uniquely"
input ComponentModel2WhereUniqueInput {
    id: ID
}

input ConnectPositionInput {
    "Connect document after specified document"
    after: ID
    "Connect document before specified document"
    before: ID
    "Connect document at last position"
    end: Boolean
    "Connect document at first position"
    start: Boolean
}

input DocumentOutputInput {
    """

    Transforms a document into a desired file type.
    See this matrix for format support:

    JPG:    autoImage, bmp, gif, jpg, png, webp, tiff
    PNG:    autoImage, bmp, gif, jpg, png, webp, tiff, svg
    SVG:    autoImage, bmp, gif, jpg, png, webp, tiff
    WEBP:    autoImage, bmp, gif, jpg, png, webp, tiff, svg
    GIF:    autoImage, bmp, gif, jpg, png, webp, tiff, svg
    TIFF:    autoImage, bmp, gif, jpg, png, webp, tiff, svg
    AVIF:    autoImage, bmp, gif, jpg, png, webp, tiff, svg
    PDF:    autoImage, gif, jpg, png, webp, tiff
    """
    format: DocumentFileTypes
}

"Transformations for Documents"
input DocumentTransformationInput {
    "Changes the output for the file."
    output: DocumentOutputInput
}

"Allows to specify input to query models and components directly"
input EntityWhereInput {
    "The ID of an object"
    id: ID!
    locale: Locale
    stage: Stage!
    "The Type name of an object"
    typename: EntityTypeName!
}

input ImageBlurInput {
    "The amount of blurring to apply to the image. The value must be an integer from 1 to 20."
    amount: Int!
}

"Adds a border to the image."
input ImageBorderInput {
    "The background color of the border. The value must be a valid hex color code. Or one of the supported color names."
    background: String!
    "The color of the border. The value must be a valid hex color code. Or one of the supported color names."
    color: String!
    "The width of the border in pixels. The value must be an integer from 1 to 1000."
    width: Int!
}

input ImageCompressInput {
    "Preserves the metadata of the image."
    metadata: Boolean!
}

"""

Crops the image to the specified dimensions.
The starting points for X and Y coordinates are [0,0], aligning with the top-left corner of the image.
The width and height parameters determine the size in pixels of the cropping rectangle.
The output will include only the portion of the image within the designated crop area.
"""
input ImageCropInput {
    "The height in pixels to resize the image to. The value must be an integer from 1 to 10000."
    height: Int!
    "The width in pixels to resize the image to. The value must be an integer from 1 to 10000."
    width: Int!
    "The x coordinate of the image. The value must be an integer from 0 to 10000."
    x: Int!
    "The y coordinate of the image. The value must be an integer from 0 to 10000."
    y: Int!
}

input ImageQualityInput {
    "The quality of the image. The value must be an integer from 1 to 100."
    value: Int!
}

input ImageResizeInput {
    "The default value for the fit parameter is fit:clip."
    fit: ImageFit
    "The height in pixels to resize the image to. The value must be an integer from 1 to 10000."
    height: Int
    "The width in pixels to resize the image to. The value must be an integer from 1 to 10000."
    width: Int
}

input ImageSharpenInput {
    "The amount of sharpening to apply to the image. The value must be an integer from 1 to 20."
    amount: Int!
}

"Transformations for Images"
input ImageTransformationInput {
    "Blurs the image."
    blur: ImageBlurInput
    "Adds a border to the image."
    border: ImageBorderInput
    "Compresses the image."
    compress: ImageCompressInput
    "Crops the image to the specified dimensions."
    crop: ImageCropInput
    """

    Changes the quality of the image. The value must be an integer from 1 to 100.
    Only supported for the following formats jpeg, jpg, webp, gif, heif, tiff, avif.
    """
    quality: ImageQualityInput
    "Resizes the image"
    resize: ImageResizeInput
    "Sharpens the image."
    sharpen: ImageSharpenInput
}

"Input for a geolocation point with latitude and longitude"
input LocationInput {
    latitude: Float!
    longitude: Float!
}

input Model1ConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: Model1WhereUniqueInput!
}

input Model1CreateInput {
    assetField: AssetCreateOneInlineInput
    booleanField: Boolean
    colorField: ColorInput
    createdAt: DateTime
    dateField: Date
    datetimeField: DateTime
    enumerationField: CustomEnumeration
    floatField: Float
    integerField: Int
    jsonField: Json
    locationField: LocationInput
    markdownField: String
    multilineField: String
    richTextField: RichTextAST
    singleToManyReference: Model2CreateManyInlineInput
    singleToManyReference2: Model2CreateManyInlineInput
    singleToOneReference: Model2CreateOneInlineInput
    slug: String!
    title: String!
    updatedAt: DateTime
}

input Model1CreateManyInlineInput {
    "Connect multiple existing Model1 documents"
    connect: [Model1WhereUniqueInput!]
    "Create and connect multiple existing Model1 documents"
    create: [Model1CreateInput!]
}

input Model1CreateOneInlineInput {
    "Connect one existing Model1 document"
    connect: Model1WhereUniqueInput
    "Create and connect one Model1 document"
    create: Model1CreateInput
}

"Identifies documents"
input Model1ManyWhereInput {
    "Logical AND on all given filters."
    AND: [Model1WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model1WhereInput!]
    "Logical OR on all given filters."
    OR: [Model1WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    assetField: AssetWhereInput
    booleanField: Boolean
    "Any other value that exists and is not equal to the given value."
    booleanField_not: Boolean
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    dateField: Date
    "All values greater than the given value."
    dateField_gt: Date
    "All values greater than or equal the given value."
    dateField_gte: Date
    "All values that are contained in given list."
    dateField_in: [Date]
    "All values less than the given value."
    dateField_lt: Date
    "All values less than or equal the given value."
    dateField_lte: Date
    "Any other value that exists and is not equal to the given value."
    dateField_not: Date
    "All values that are not contained in given list."
    dateField_not_in: [Date]
    datetimeField: DateTime
    "All values greater than the given value."
    datetimeField_gt: DateTime
    "All values greater than or equal the given value."
    datetimeField_gte: DateTime
    "All values that are contained in given list."
    datetimeField_in: [DateTime]
    "All values less than the given value."
    datetimeField_lt: DateTime
    "All values less than or equal the given value."
    datetimeField_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    datetimeField_not: DateTime
    "All values that are not contained in given list."
    datetimeField_not_in: [DateTime]
    documentInStages_every: Model1WhereStageInput
    documentInStages_none: Model1WhereStageInput
    documentInStages_some: Model1WhereStageInput
    enumerationField: CustomEnumeration
    "All values that are contained in given list."
    enumerationField_in: [CustomEnumeration]
    "Any other value that exists and is not equal to the given value."
    enumerationField_not: CustomEnumeration
    "All values that are not contained in given list."
    enumerationField_not_in: [CustomEnumeration]
    floatField: Float
    "All values greater than the given value."
    floatField_gt: Float
    "All values greater than or equal the given value."
    floatField_gte: Float
    "All values that are contained in given list."
    floatField_in: [Float]
    "All values less than the given value."
    floatField_lt: Float
    "All values less than or equal the given value."
    floatField_lte: Float
    "Any other value that exists and is not equal to the given value."
    floatField_not: Float
    "All values that are not contained in given list."
    floatField_not_in: [Float]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    integerField: Int
    "All values greater than the given value."
    integerField_gt: Int
    "All values greater than or equal the given value."
    integerField_gte: Int
    "All values that are contained in given list."
    integerField_in: [Int]
    "All values less than the given value."
    integerField_lt: Int
    "All values less than or equal the given value."
    integerField_lte: Int
    "Any other value that exists and is not equal to the given value."
    integerField_not: Int
    "All values that are not contained in given list."
    integerField_not_in: [Int]
    "All values containing the given json path."
    jsonField_json_path_exists: String
    """

    Recursively tries to find the provided JSON scalar value inside the field.
    It does use an exact match when comparing values.
    If you pass `null` as value the filter will be ignored.
    Note: This filter fails if you try to look for a non scalar JSON value!
    """
    jsonField_value_recursive: Json
    markdownField: String
    "All values containing the given string."
    markdownField_contains: String
    "All values ending with the given string."
    markdownField_ends_with: String
    "All values that are contained in given list."
    markdownField_in: [String]
    "Any other value that exists and is not equal to the given value."
    markdownField_not: String
    "All values not containing the given string."
    markdownField_not_contains: String
    "All values not ending with the given string"
    markdownField_not_ends_with: String
    "All values that are not contained in given list."
    markdownField_not_in: [String]
    "All values not starting with the given string."
    markdownField_not_starts_with: String
    "All values starting with the given string."
    markdownField_starts_with: String
    multilineField: String
    "All values containing the given string."
    multilineField_contains: String
    "All values ending with the given string."
    multilineField_ends_with: String
    "All values that are contained in given list."
    multilineField_in: [String]
    "Any other value that exists and is not equal to the given value."
    multilineField_not: String
    "All values not containing the given string."
    multilineField_not_contains: String
    "All values not ending with the given string"
    multilineField_not_ends_with: String
    "All values that are not contained in given list."
    multilineField_not_in: [String]
    "All values not starting with the given string."
    multilineField_not_starts_with: String
    "All values starting with the given string."
    multilineField_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    singleToManyReference2_every: Model2WhereInput
    singleToManyReference2_none: Model2WhereInput
    singleToManyReference2_some: Model2WhereInput
    singleToManyReference_every: Model2WhereInput
    singleToManyReference_none: Model2WhereInput
    singleToManyReference_some: Model2WhereInput
    singleToOneReference: Model2WhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String]
    "Any other value that exists and is not equal to the given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

input Model1UpdateInput {
    assetField: AssetUpdateOneInlineInput
    booleanField: Boolean
    colorField: ColorInput
    dateField: Date
    datetimeField: DateTime
    enumerationField: CustomEnumeration
    floatField: Float
    integerField: Int
    jsonField: Json
    locationField: LocationInput
    markdownField: String
    multilineField: String
    richTextField: RichTextAST
    singleToManyReference: Model2UpdateManyInlineInput
    singleToManyReference2: Model2UpdateManyInlineInput
    singleToOneReference: Model2UpdateOneInlineInput
    slug: String
    title: String
}

input Model1UpdateManyInlineInput {
    "Connect multiple existing Model1 documents"
    connect: [Model1ConnectInput!]
    "Create and connect multiple Model1 documents"
    create: [Model1CreateInput!]
    "Delete multiple Model1 documents"
    delete: [Model1WhereUniqueInput!]
    "Disconnect multiple Model1 documents"
    disconnect: [Model1WhereUniqueInput!]
    "Override currently-connected documents with multiple existing Model1 documents"
    set: [Model1WhereUniqueInput!]
    "Update multiple Model1 documents"
    update: [Model1UpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Model1 documents"
    upsert: [Model1UpsertWithNestedWhereUniqueInput!]
}

input Model1UpdateManyInput {
    booleanField: Boolean
    colorField: ColorInput
    dateField: Date
    datetimeField: DateTime
    enumerationField: CustomEnumeration
    floatField: Float
    integerField: Int
    jsonField: Json
    locationField: LocationInput
    markdownField: String
    multilineField: String
    richTextField: RichTextAST
    title: String
}

input Model1UpdateManyWithNestedWhereInput {
    "Update many input"
    data: Model1UpdateManyInput!
    "Document search"
    where: Model1WhereInput!
}

input Model1UpdateOneInlineInput {
    "Connect existing Model1 document"
    connect: Model1WhereUniqueInput
    "Create and connect one Model1 document"
    create: Model1CreateInput
    "Delete currently connected Model1 document"
    delete: Boolean
    "Disconnect currently connected Model1 document"
    disconnect: Boolean
    "Update single Model1 document"
    update: Model1UpdateWithNestedWhereUniqueInput
    "Upsert single Model1 document"
    upsert: Model1UpsertWithNestedWhereUniqueInput
}

input Model1UpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: Model1UpdateInput!
    "Unique document search"
    where: Model1WhereUniqueInput!
}

input Model1UpsertInput {
    "Create document if it didn't exist"
    create: Model1CreateInput!
    "Update document if it exists"
    update: Model1UpdateInput!
}

input Model1UpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: Model1UpsertInput!
    "Unique document search"
    where: Model1WhereUniqueInput!
}

"This contains a set of filters that can be used to compare values internally"
input Model1WhereComparatorInput {
    "This field can be used to request to check if the entry is outdated by internal comparison"
    outdated_to: Boolean
}

"Identifies documents"
input Model1WhereInput {
    "Logical AND on all given filters."
    AND: [Model1WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model1WhereInput!]
    "Logical OR on all given filters."
    OR: [Model1WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    assetField: AssetWhereInput
    booleanField: Boolean
    "Any other value that exists and is not equal to the given value."
    booleanField_not: Boolean
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    dateField: Date
    "All values greater than the given value."
    dateField_gt: Date
    "All values greater than or equal the given value."
    dateField_gte: Date
    "All values that are contained in given list."
    dateField_in: [Date]
    "All values less than the given value."
    dateField_lt: Date
    "All values less than or equal the given value."
    dateField_lte: Date
    "Any other value that exists and is not equal to the given value."
    dateField_not: Date
    "All values that are not contained in given list."
    dateField_not_in: [Date]
    datetimeField: DateTime
    "All values greater than the given value."
    datetimeField_gt: DateTime
    "All values greater than or equal the given value."
    datetimeField_gte: DateTime
    "All values that are contained in given list."
    datetimeField_in: [DateTime]
    "All values less than the given value."
    datetimeField_lt: DateTime
    "All values less than or equal the given value."
    datetimeField_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    datetimeField_not: DateTime
    "All values that are not contained in given list."
    datetimeField_not_in: [DateTime]
    documentInStages_every: Model1WhereStageInput
    documentInStages_none: Model1WhereStageInput
    documentInStages_some: Model1WhereStageInput
    enumerationField: CustomEnumeration
    "All values that are contained in given list."
    enumerationField_in: [CustomEnumeration]
    "Any other value that exists and is not equal to the given value."
    enumerationField_not: CustomEnumeration
    "All values that are not contained in given list."
    enumerationField_not_in: [CustomEnumeration]
    floatField: Float
    "All values greater than the given value."
    floatField_gt: Float
    "All values greater than or equal the given value."
    floatField_gte: Float
    "All values that are contained in given list."
    floatField_in: [Float]
    "All values less than the given value."
    floatField_lt: Float
    "All values less than or equal the given value."
    floatField_lte: Float
    "Any other value that exists and is not equal to the given value."
    floatField_not: Float
    "All values that are not contained in given list."
    floatField_not_in: [Float]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    integerField: Int
    "All values greater than the given value."
    integerField_gt: Int
    "All values greater than or equal the given value."
    integerField_gte: Int
    "All values that are contained in given list."
    integerField_in: [Int]
    "All values less than the given value."
    integerField_lt: Int
    "All values less than or equal the given value."
    integerField_lte: Int
    "Any other value that exists and is not equal to the given value."
    integerField_not: Int
    "All values that are not contained in given list."
    integerField_not_in: [Int]
    "All values containing the given json path."
    jsonField_json_path_exists: String
    """

    Recursively tries to find the provided JSON scalar value inside the field.
    It does use an exact match when comparing values.
    If you pass `null` as value the filter will be ignored.
    Note: This filter fails if you try to look for a non scalar JSON value!
    """
    jsonField_value_recursive: Json
    markdownField: String
    "All values containing the given string."
    markdownField_contains: String
    "All values ending with the given string."
    markdownField_ends_with: String
    "All values that are contained in given list."
    markdownField_in: [String]
    "Any other value that exists and is not equal to the given value."
    markdownField_not: String
    "All values not containing the given string."
    markdownField_not_contains: String
    "All values not ending with the given string"
    markdownField_not_ends_with: String
    "All values that are not contained in given list."
    markdownField_not_in: [String]
    "All values not starting with the given string."
    markdownField_not_starts_with: String
    "All values starting with the given string."
    markdownField_starts_with: String
    multilineField: String
    "All values containing the given string."
    multilineField_contains: String
    "All values ending with the given string."
    multilineField_ends_with: String
    "All values that are contained in given list."
    multilineField_in: [String]
    "Any other value that exists and is not equal to the given value."
    multilineField_not: String
    "All values not containing the given string."
    multilineField_not_contains: String
    "All values not ending with the given string"
    multilineField_not_ends_with: String
    "All values that are not contained in given list."
    multilineField_not_in: [String]
    "All values not starting with the given string."
    multilineField_not_starts_with: String
    "All values starting with the given string."
    multilineField_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    singleToManyReference2_every: Model2WhereInput
    singleToManyReference2_none: Model2WhereInput
    singleToManyReference2_some: Model2WhereInput
    singleToManyReference_every: Model2WhereInput
    singleToManyReference_none: Model2WhereInput
    singleToManyReference_some: Model2WhereInput
    singleToOneReference: Model2WhereInput
    slug: String
    "All values containing the given string."
    slug_contains: String
    "All values ending with the given string."
    slug_ends_with: String
    "All values that are contained in given list."
    slug_in: [String]
    "Any other value that exists and is not equal to the given value."
    slug_not: String
    "All values not containing the given string."
    slug_not_contains: String
    "All values not ending with the given string"
    slug_not_ends_with: String
    "All values that are not contained in given list."
    slug_not_in: [String]
    "All values not starting with the given string."
    slug_not_starts_with: String
    "All values starting with the given string."
    slug_starts_with: String
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

"The document in stages filter allows specifying a stage entry to cross compare the same document between different stages"
input Model1WhereStageInput {
    "Logical AND on all given filters."
    AND: [Model1WhereStageInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model1WhereStageInput!]
    "Logical OR on all given filters."
    OR: [Model1WhereStageInput!]
    "This field contains fields which can be set as true or false to specify an internal comparison"
    compareWithParent: Model1WhereComparatorInput
    "Specify the stage to compare with"
    stage: Stage
}

"References Model1 record uniquely"
input Model1WhereUniqueInput {
    id: ID
    slug: String
}

input Model2ConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: Model2WhereUniqueInput!
}

input Model2CreateInput {
    componentModel1: ComponentModel1CreateOneInlineInput
    createdAt: DateTime
    multiComponentField: Model2multiComponentFieldUnionCreateOneInlineInput
    multiToManyReference: multiToManyReferenceMultiToManyReferenceCreateManyInlineInput
    multiToOneReference: singleToOneReferenceMultiToOneReferenceCreateOneInlineInput
    multiToOneReference2: singleToManyReference2MultiToOneReference2CreateOneInlineInput
    singleComponentField: ComponentModel1CreateOneInlineInput
    singleToManyReference: Model3CreateManyInlineInput
    singleToManyReference3: Model3CreateManyInlineInput
    singleToOneReference: Model3CreateOneInlineInput
    singleToOneReference2: Model3CreateOneInlineInput
    title: String
    updatedAt: DateTime
}

input Model2CreateManyInlineInput {
    "Connect multiple existing Model2 documents"
    connect: [Model2WhereUniqueInput!]
    "Create and connect multiple existing Model2 documents"
    create: [Model2CreateInput!]
}

input Model2CreateOneInlineInput {
    "Connect one existing Model2 document"
    connect: Model2WhereUniqueInput
    "Create and connect one Model2 document"
    create: Model2CreateInput
}

"Identifies documents"
input Model2ManyWhereInput {
    "Logical AND on all given filters."
    AND: [Model2WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model2WhereInput!]
    "Logical OR on all given filters."
    OR: [Model2WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    documentInStages_every: Model2WhereStageInput
    documentInStages_none: Model2WhereStageInput
    documentInStages_some: Model2WhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    "All values in which the modular component is connected to the given models"
    multiComponentField: Model2multiComponentFieldUnionWhereInput
    "All values in which the union is empty."
    multiComponentField_empty: Boolean
    "All values in which the union is empty"
    multiToManyReference_empty: Boolean
    "Matches if the union contains at least one connection to the provided item to the filter"
    multiToManyReference_some: multiToManyReferenceMultiToManyReferenceWhereInput
    "All values in which the union is connected to the given models"
    multiToOneReference: singleToOneReferenceMultiToOneReferenceWhereInput
    "All values in which the union is connected to the given models"
    multiToOneReference2: singleToManyReference2MultiToOneReference2WhereInput
    "All values in which the union is empty"
    multiToOneReference2_empty: Boolean
    "All values in which the union is empty"
    multiToOneReference_empty: Boolean
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    singleComponentField: ComponentModel1WhereInput
    singleToManyReference3_every: Model3WhereInput
    singleToManyReference3_none: Model3WhereInput
    singleToManyReference3_some: Model3WhereInput
    singleToManyReference_every: Model3WhereInput
    singleToManyReference_none: Model3WhereInput
    singleToManyReference_some: Model3WhereInput
    singleToOneReference: Model3WhereInput
    singleToOneReference2: Model3WhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

input Model2UpdateInput {
    componentModel1: ComponentModel1UpdateOneInlineInput
    multiComponentField: Model2multiComponentFieldUnionUpdateOneInlineInput
    multiToManyReference: multiToManyReferenceMultiToManyReferenceUpdateManyInlineInput
    multiToOneReference: singleToOneReferenceMultiToOneReferenceUpdateOneInlineInput
    multiToOneReference2: singleToManyReference2MultiToOneReference2UpdateOneInlineInput
    singleComponentField: ComponentModel1UpdateOneInlineInput
    singleToManyReference: Model3UpdateManyInlineInput
    singleToManyReference3: Model3UpdateManyInlineInput
    singleToOneReference: Model3UpdateOneInlineInput
    singleToOneReference2: Model3UpdateOneInlineInput
    title: String
}

input Model2UpdateManyInlineInput {
    "Connect multiple existing Model2 documents"
    connect: [Model2ConnectInput!]
    "Create and connect multiple Model2 documents"
    create: [Model2CreateInput!]
    "Delete multiple Model2 documents"
    delete: [Model2WhereUniqueInput!]
    "Disconnect multiple Model2 documents"
    disconnect: [Model2WhereUniqueInput!]
    "Override currently-connected documents with multiple existing Model2 documents"
    set: [Model2WhereUniqueInput!]
    "Update multiple Model2 documents"
    update: [Model2UpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Model2 documents"
    upsert: [Model2UpsertWithNestedWhereUniqueInput!]
}

input Model2UpdateManyInput {
    title: String
}

input Model2UpdateManyWithNestedWhereInput {
    "Update many input"
    data: Model2UpdateManyInput!
    "Document search"
    where: Model2WhereInput!
}

input Model2UpdateOneInlineInput {
    "Connect existing Model2 document"
    connect: Model2WhereUniqueInput
    "Create and connect one Model2 document"
    create: Model2CreateInput
    "Delete currently connected Model2 document"
    delete: Boolean
    "Disconnect currently connected Model2 document"
    disconnect: Boolean
    "Update single Model2 document"
    update: Model2UpdateWithNestedWhereUniqueInput
    "Upsert single Model2 document"
    upsert: Model2UpsertWithNestedWhereUniqueInput
}

input Model2UpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: Model2UpdateInput!
    "Unique document search"
    where: Model2WhereUniqueInput!
}

input Model2UpsertInput {
    "Create document if it didn't exist"
    create: Model2CreateInput!
    "Update document if it exists"
    update: Model2UpdateInput!
}

input Model2UpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: Model2UpsertInput!
    "Unique document search"
    where: Model2WhereUniqueInput!
}

"This contains a set of filters that can be used to compare values internally"
input Model2WhereComparatorInput {
    "This field can be used to request to check if the entry is outdated by internal comparison"
    outdated_to: Boolean
}

"Identifies documents"
input Model2WhereInput {
    "Logical AND on all given filters."
    AND: [Model2WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model2WhereInput!]
    "Logical OR on all given filters."
    OR: [Model2WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    documentInStages_every: Model2WhereStageInput
    documentInStages_none: Model2WhereStageInput
    documentInStages_some: Model2WhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    "All values in which the modular component is connected to the given models"
    multiComponentField: Model2multiComponentFieldUnionWhereInput
    "All values in which the union is empty."
    multiComponentField_empty: Boolean
    "All values in which the union is empty"
    multiToManyReference_empty: Boolean
    "Matches if the union contains at least one connection to the provided item to the filter"
    multiToManyReference_some: multiToManyReferenceMultiToManyReferenceWhereInput
    "All values in which the union is connected to the given models"
    multiToOneReference: singleToOneReferenceMultiToOneReferenceWhereInput
    "All values in which the union is connected to the given models"
    multiToOneReference2: singleToManyReference2MultiToOneReference2WhereInput
    "All values in which the union is empty"
    multiToOneReference2_empty: Boolean
    "All values in which the union is empty"
    multiToOneReference_empty: Boolean
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    singleComponentField: ComponentModel1WhereInput
    singleToManyReference3_every: Model3WhereInput
    singleToManyReference3_none: Model3WhereInput
    singleToManyReference3_some: Model3WhereInput
    singleToManyReference_every: Model3WhereInput
    singleToManyReference_none: Model3WhereInput
    singleToManyReference_some: Model3WhereInput
    singleToOneReference: Model3WhereInput
    singleToOneReference2: Model3WhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

"The document in stages filter allows specifying a stage entry to cross compare the same document between different stages"
input Model2WhereStageInput {
    "Logical AND on all given filters."
    AND: [Model2WhereStageInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model2WhereStageInput!]
    "Logical OR on all given filters."
    OR: [Model2WhereStageInput!]
    "This field contains fields which can be set as true or false to specify an internal comparison"
    compareWithParent: Model2WhereComparatorInput
    "Specify the stage to compare with"
    stage: Stage
}

"References Model2 record uniquely"
input Model2WhereUniqueInput {
    id: ID
}

input Model2multiComponentFieldUnionConnectInput {
    ComponentModel1: ComponentModel1ConnectInput
    ComponentModel2: ComponentModel2ConnectInput
}

input Model2multiComponentFieldUnionCreateInput {
    ComponentModel1: ComponentModel1CreateInput
    ComponentModel2: ComponentModel2CreateInput
}

input Model2multiComponentFieldUnionCreateManyInlineInput {
    "Create and connect multiple existing Model2multiComponentFieldUnion documents"
    create: [Model2multiComponentFieldUnionCreateInput!]
}

input Model2multiComponentFieldUnionCreateOneInlineInput {
    "Create and connect one Model2multiComponentFieldUnion document"
    create: Model2multiComponentFieldUnionCreateInput
}

input Model2multiComponentFieldUnionCreateWithPositionInput {
    ComponentModel1: ComponentModel1CreateWithPositionInput
    ComponentModel2: ComponentModel2CreateWithPositionInput
}

input Model2multiComponentFieldUnionUpdateInput {
    ComponentModel1: ComponentModel1UpdateInput
    ComponentModel2: ComponentModel2UpdateInput
}

input Model2multiComponentFieldUnionUpdateManyInlineInput {
    "Create and connect multiple Model2multiComponentFieldUnion component instances"
    create: [Model2multiComponentFieldUnionCreateWithPositionInput!]
    "Delete multiple Model2multiComponentFieldUnion documents"
    delete: [Model2multiComponentFieldUnionWhereUniqueInput!]
    "Update multiple Model2multiComponentFieldUnion component instances"
    update: [Model2multiComponentFieldUnionUpdateWithNestedWhereUniqueAndPositionInput!]
    "Upsert multiple Model2multiComponentFieldUnion component instances"
    upsert: [Model2multiComponentFieldUnionUpsertWithNestedWhereUniqueAndPositionInput!]
}

input Model2multiComponentFieldUnionUpdateManyWithNestedWhereInput {
    ComponentModel1: ComponentModel1UpdateManyWithNestedWhereInput
    ComponentModel2: ComponentModel2UpdateManyWithNestedWhereInput
}

input Model2multiComponentFieldUnionUpdateOneInlineInput {
    "Create and connect one Model2multiComponentFieldUnion document"
    create: Model2multiComponentFieldUnionCreateInput
    "Delete currently connected Model2multiComponentFieldUnion document"
    delete: Boolean
    "Update single Model2multiComponentFieldUnion document"
    update: Model2multiComponentFieldUnionUpdateWithNestedWhereUniqueInput
    "Upsert single Model2multiComponentFieldUnion document"
    upsert: Model2multiComponentFieldUnionUpsertWithNestedWhereUniqueInput
}

input Model2multiComponentFieldUnionUpdateWithNestedWhereUniqueAndPositionInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueAndPositionInput
    ComponentModel2: ComponentModel2UpdateWithNestedWhereUniqueAndPositionInput
}

input Model2multiComponentFieldUnionUpdateWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueInput
    ComponentModel2: ComponentModel2UpdateWithNestedWhereUniqueInput
}

input Model2multiComponentFieldUnionUpsertWithNestedWhereUniqueAndPositionInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueAndPositionInput
    ComponentModel2: ComponentModel2UpsertWithNestedWhereUniqueAndPositionInput
}

input Model2multiComponentFieldUnionUpsertWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueInput
    ComponentModel2: ComponentModel2UpsertWithNestedWhereUniqueInput
}

input Model2multiComponentFieldUnionWhereInput {
    ComponentModel1: ComponentModel1WhereInput
    ComponentModel2: ComponentModel2WhereInput
}

input Model2multiComponentFieldUnionWhereUniqueInput {
    ComponentModel1: ComponentModel1WhereUniqueInput
    ComponentModel2: ComponentModel2WhereUniqueInput
}

input Model3ConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: Model3WhereUniqueInput!
}

input Model3CreateInput {
    clyrbcgse03h207lh7gxw8bdd: Model2CreateManyInlineInput
    clyrbcwva03ie07lh74zi275s: Model2CreateManyInlineInput
    createdAt: DateTime
    listOfAssets: AssetCreateManyInlineInput
    listOfEnums: [CustomEnumeration!]
    listOfFloats: [Float!]
    listOfIntegers: [Int!]
    listOfMultiComponents: Model3listOfMultiComponentsUnionCreateManyInlineInput
    listOfMultiline: [String!]
    listOfSingleComponents: ComponentModel1CreateManyInlineInput
    listOfStrings: [String!]
    singleToManyReference: Model2CreateOneInlineInput
    singleToManyReference2: Model2CreateManyInlineInput
    singleToManyReference3: Model2CreateManyInlineInput
    singleToManyReference4: Model2CreateManyInlineInput
    singleToOneReference: Model2CreateOneInlineInput
    title: String
    updatedAt: DateTime
}

input Model3CreateManyInlineInput {
    "Connect multiple existing Model3 documents"
    connect: [Model3WhereUniqueInput!]
    "Create and connect multiple existing Model3 documents"
    create: [Model3CreateInput!]
}

input Model3CreateOneInlineInput {
    "Connect one existing Model3 document"
    connect: Model3WhereUniqueInput
    "Create and connect one Model3 document"
    create: Model3CreateInput
}

"Identifies documents"
input Model3ManyWhereInput {
    "Logical AND on all given filters."
    AND: [Model3WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model3WhereInput!]
    "Logical OR on all given filters."
    OR: [Model3WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    documentInStages_every: Model3WhereStageInput
    documentInStages_none: Model3WhereStageInput
    documentInStages_some: Model3WhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    listOfAssets_every: AssetWhereInput
    listOfAssets_none: AssetWhereInput
    listOfAssets_some: AssetWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfEnums: [CustomEnumeration!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfEnums_contains_all: [CustomEnumeration!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfEnums_contains_none: [CustomEnumeration!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfEnums_contains_some: [CustomEnumeration!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfEnums_not: [CustomEnumeration!]
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfFloats: [Float!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfFloats_contains_all: [Float!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfFloats_contains_none: [Float!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfFloats_contains_some: [Float!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfFloats_not: [Float!]
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfIntegers: [Int!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfIntegers_contains_all: [Int!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfIntegers_contains_none: [Int!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfIntegers_contains_some: [Int!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfIntegers_not: [Int!]
    "All values in which the union is empty."
    listOfMultiComponents_empty: Boolean
    "Matches if the modular component contains at least one connection to the item provided to the filter"
    listOfMultiComponents_some: Model3listOfMultiComponentsUnionWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfMultiline: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfMultiline_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfMultiline_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfMultiline_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfMultiline_not: [String!]
    listOfSingleComponents_every: ComponentModel1WhereInput
    listOfSingleComponents_none: ComponentModel1WhereInput
    listOfSingleComponents_some: ComponentModel1WhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfStrings: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfStrings_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfStrings_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfStrings_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfStrings_not: [String!]
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    singleToManyReference: Model2WhereInput
    singleToManyReference2_every: Model2WhereInput
    singleToManyReference2_none: Model2WhereInput
    singleToManyReference2_some: Model2WhereInput
    singleToManyReference3_every: Model2WhereInput
    singleToManyReference3_none: Model2WhereInput
    singleToManyReference3_some: Model2WhereInput
    singleToManyReference4_every: Model2WhereInput
    singleToManyReference4_none: Model2WhereInput
    singleToManyReference4_some: Model2WhereInput
    singleToOneReference: Model2WhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

input Model3UpdateInput {
    clyrbcgse03h207lh7gxw8bdd: Model2UpdateManyInlineInput
    clyrbcwva03ie07lh74zi275s: Model2UpdateManyInlineInput
    listOfAssets: AssetUpdateManyInlineInput
    listOfEnums: [CustomEnumeration!]
    listOfFloats: [Float!]
    listOfIntegers: [Int!]
    listOfMultiComponents: Model3listOfMultiComponentsUnionUpdateManyInlineInput
    listOfMultiline: [String!]
    listOfSingleComponents: ComponentModel1UpdateManyInlineInput
    listOfStrings: [String!]
    singleToManyReference: Model2UpdateOneInlineInput
    singleToManyReference2: Model2UpdateManyInlineInput
    singleToManyReference3: Model2UpdateManyInlineInput
    singleToManyReference4: Model2UpdateManyInlineInput
    singleToOneReference: Model2UpdateOneInlineInput
    title: String
}

input Model3UpdateManyInlineInput {
    "Connect multiple existing Model3 documents"
    connect: [Model3ConnectInput!]
    "Create and connect multiple Model3 documents"
    create: [Model3CreateInput!]
    "Delete multiple Model3 documents"
    delete: [Model3WhereUniqueInput!]
    "Disconnect multiple Model3 documents"
    disconnect: [Model3WhereUniqueInput!]
    "Override currently-connected documents with multiple existing Model3 documents"
    set: [Model3WhereUniqueInput!]
    "Update multiple Model3 documents"
    update: [Model3UpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Model3 documents"
    upsert: [Model3UpsertWithNestedWhereUniqueInput!]
}

input Model3UpdateManyInput {
    listOfEnums: [CustomEnumeration!]
    listOfFloats: [Float!]
    listOfIntegers: [Int!]
    listOfMultiline: [String!]
    listOfStrings: [String!]
    title: String
}

input Model3UpdateManyWithNestedWhereInput {
    "Update many input"
    data: Model3UpdateManyInput!
    "Document search"
    where: Model3WhereInput!
}

input Model3UpdateOneInlineInput {
    "Connect existing Model3 document"
    connect: Model3WhereUniqueInput
    "Create and connect one Model3 document"
    create: Model3CreateInput
    "Delete currently connected Model3 document"
    delete: Boolean
    "Disconnect currently connected Model3 document"
    disconnect: Boolean
    "Update single Model3 document"
    update: Model3UpdateWithNestedWhereUniqueInput
    "Upsert single Model3 document"
    upsert: Model3UpsertWithNestedWhereUniqueInput
}

input Model3UpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: Model3UpdateInput!
    "Unique document search"
    where: Model3WhereUniqueInput!
}

input Model3UpsertInput {
    "Create document if it didn't exist"
    create: Model3CreateInput!
    "Update document if it exists"
    update: Model3UpdateInput!
}

input Model3UpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: Model3UpsertInput!
    "Unique document search"
    where: Model3WhereUniqueInput!
}

"This contains a set of filters that can be used to compare values internally"
input Model3WhereComparatorInput {
    "This field can be used to request to check if the entry is outdated by internal comparison"
    outdated_to: Boolean
}

"Identifies documents"
input Model3WhereInput {
    "Logical AND on all given filters."
    AND: [Model3WhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model3WhereInput!]
    "Logical OR on all given filters."
    OR: [Model3WhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    documentInStages_every: Model3WhereStageInput
    documentInStages_none: Model3WhereStageInput
    documentInStages_some: Model3WhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    listOfAssets_every: AssetWhereInput
    listOfAssets_none: AssetWhereInput
    listOfAssets_some: AssetWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfEnums: [CustomEnumeration!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfEnums_contains_all: [CustomEnumeration!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfEnums_contains_none: [CustomEnumeration!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfEnums_contains_some: [CustomEnumeration!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfEnums_not: [CustomEnumeration!]
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfFloats: [Float!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfFloats_contains_all: [Float!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfFloats_contains_none: [Float!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfFloats_contains_some: [Float!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfFloats_not: [Float!]
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfIntegers: [Int!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfIntegers_contains_all: [Int!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfIntegers_contains_none: [Int!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfIntegers_contains_some: [Int!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfIntegers_not: [Int!]
    "All values in which the union is empty."
    listOfMultiComponents_empty: Boolean
    "Matches if the modular component contains at least one connection to the item provided to the filter"
    listOfMultiComponents_some: Model3listOfMultiComponentsUnionWhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfMultiline: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfMultiline_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfMultiline_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfMultiline_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfMultiline_not: [String!]
    listOfSingleComponents_every: ComponentModel1WhereInput
    listOfSingleComponents_none: ComponentModel1WhereInput
    listOfSingleComponents_some: ComponentModel1WhereInput
    "Matches if the field array contains *all* items provided to the filter and order does match"
    listOfStrings: [String!]
    "Matches if the field array contains *all* items provided to the filter"
    listOfStrings_contains_all: [String!]
    "Matches if the field array does not contain any of the items provided to the filter"
    listOfStrings_contains_none: [String!]
    "Matches if the field array contains at least one item provided to the filter"
    listOfStrings_contains_some: [String!]
    "Matches if the field array does not contains *all* items provided to the filter or order does not match"
    listOfStrings_not: [String!]
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    scheduledIn_every: ScheduledOperationWhereInput
    scheduledIn_none: ScheduledOperationWhereInput
    scheduledIn_some: ScheduledOperationWhereInput
    singleToManyReference: Model2WhereInput
    singleToManyReference2_every: Model2WhereInput
    singleToManyReference2_none: Model2WhereInput
    singleToManyReference2_some: Model2WhereInput
    singleToManyReference3_every: Model2WhereInput
    singleToManyReference3_none: Model2WhereInput
    singleToManyReference3_some: Model2WhereInput
    singleToManyReference4_every: Model2WhereInput
    singleToManyReference4_none: Model2WhereInput
    singleToManyReference4_some: Model2WhereInput
    singleToOneReference: Model2WhereInput
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

"The document in stages filter allows specifying a stage entry to cross compare the same document between different stages"
input Model3WhereStageInput {
    "Logical AND on all given filters."
    AND: [Model3WhereStageInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [Model3WhereStageInput!]
    "Logical OR on all given filters."
    OR: [Model3WhereStageInput!]
    "This field contains fields which can be set as true or false to specify an internal comparison"
    compareWithParent: Model3WhereComparatorInput
    "Specify the stage to compare with"
    stage: Stage
}

"References Model3 record uniquely"
input Model3WhereUniqueInput {
    id: ID
}

input Model3listOfMultiComponentsUnionConnectInput {
    ComponentModel1: ComponentModel1ConnectInput
    ComponentModel2: ComponentModel2ConnectInput
}

input Model3listOfMultiComponentsUnionCreateInput {
    ComponentModel1: ComponentModel1CreateInput
    ComponentModel2: ComponentModel2CreateInput
}

input Model3listOfMultiComponentsUnionCreateManyInlineInput {
    "Create and connect multiple existing Model3listOfMultiComponentsUnion documents"
    create: [Model3listOfMultiComponentsUnionCreateInput!]
}

input Model3listOfMultiComponentsUnionCreateOneInlineInput {
    "Create and connect one Model3listOfMultiComponentsUnion document"
    create: Model3listOfMultiComponentsUnionCreateInput
}

input Model3listOfMultiComponentsUnionCreateWithPositionInput {
    ComponentModel1: ComponentModel1CreateWithPositionInput
    ComponentModel2: ComponentModel2CreateWithPositionInput
}

input Model3listOfMultiComponentsUnionUpdateInput {
    ComponentModel1: ComponentModel1UpdateInput
    ComponentModel2: ComponentModel2UpdateInput
}

input Model3listOfMultiComponentsUnionUpdateManyInlineInput {
    "Create and connect multiple Model3listOfMultiComponentsUnion component instances"
    create: [Model3listOfMultiComponentsUnionCreateWithPositionInput!]
    "Delete multiple Model3listOfMultiComponentsUnion documents"
    delete: [Model3listOfMultiComponentsUnionWhereUniqueInput!]
    "Update multiple Model3listOfMultiComponentsUnion component instances"
    update: [Model3listOfMultiComponentsUnionUpdateWithNestedWhereUniqueAndPositionInput!]
    "Upsert multiple Model3listOfMultiComponentsUnion component instances"
    upsert: [Model3listOfMultiComponentsUnionUpsertWithNestedWhereUniqueAndPositionInput!]
}

input Model3listOfMultiComponentsUnionUpdateManyWithNestedWhereInput {
    ComponentModel1: ComponentModel1UpdateManyWithNestedWhereInput
    ComponentModel2: ComponentModel2UpdateManyWithNestedWhereInput
}

input Model3listOfMultiComponentsUnionUpdateOneInlineInput {
    "Create and connect one Model3listOfMultiComponentsUnion document"
    create: Model3listOfMultiComponentsUnionCreateInput
    "Delete currently connected Model3listOfMultiComponentsUnion document"
    delete: Boolean
    "Update single Model3listOfMultiComponentsUnion document"
    update: Model3listOfMultiComponentsUnionUpdateWithNestedWhereUniqueInput
    "Upsert single Model3listOfMultiComponentsUnion document"
    upsert: Model3listOfMultiComponentsUnionUpsertWithNestedWhereUniqueInput
}

input Model3listOfMultiComponentsUnionUpdateWithNestedWhereUniqueAndPositionInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueAndPositionInput
    ComponentModel2: ComponentModel2UpdateWithNestedWhereUniqueAndPositionInput
}

input Model3listOfMultiComponentsUnionUpdateWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpdateWithNestedWhereUniqueInput
    ComponentModel2: ComponentModel2UpdateWithNestedWhereUniqueInput
}

input Model3listOfMultiComponentsUnionUpsertWithNestedWhereUniqueAndPositionInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueAndPositionInput
    ComponentModel2: ComponentModel2UpsertWithNestedWhereUniqueAndPositionInput
}

input Model3listOfMultiComponentsUnionUpsertWithNestedWhereUniqueInput {
    ComponentModel1: ComponentModel1UpsertWithNestedWhereUniqueInput
    ComponentModel2: ComponentModel2UpsertWithNestedWhereUniqueInput
}

input Model3listOfMultiComponentsUnionWhereInput {
    ComponentModel1: ComponentModel1WhereInput
    ComponentModel2: ComponentModel2WhereInput
}

input Model3listOfMultiComponentsUnionWhereUniqueInput {
    ComponentModel1: ComponentModel1WhereUniqueInput
    ComponentModel2: ComponentModel2WhereUniqueInput
}

input PublishLocaleInput {
    "Locales to publish"
    locale: Locale!
    "Stages to publish selected locales to"
    stages: [Stage!]!
}

"Input type representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
input RGBAInput {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

input ScheduledOperationConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ScheduledOperationWhereUniqueInput!
}

input ScheduledOperationCreateManyInlineInput {
    "Connect multiple existing ScheduledOperation documents"
    connect: [ScheduledOperationWhereUniqueInput!]
}

input ScheduledOperationCreateOneInlineInput {
    "Connect one existing ScheduledOperation document"
    connect: ScheduledOperationWhereUniqueInput
}

"Identifies documents"
input ScheduledOperationManyWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledOperationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledOperationWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledOperationWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String]
    "Any other value that exists and is not equal to the given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String]
    "Any other value that exists and is not equal to the given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    "All values containing the given json path."
    rawPayload_json_path_exists: String
    """

    Recursively tries to find the provided JSON scalar value inside the field.
    It does use an exact match when comparing values.
    If you pass `null` as value the filter will be ignored.
    Note: This filter fails if you try to look for a non scalar JSON value!
    """
    rawPayload_value_recursive: Json
    release: ScheduledReleaseWhereInput
    status: ScheduledOperationStatus
    "All values that are contained in given list."
    status_in: [ScheduledOperationStatus]
    "Any other value that exists and is not equal to the given value."
    status_not: ScheduledOperationStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledOperationStatus]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

input ScheduledOperationUpdateManyInlineInput {
    "Connect multiple existing ScheduledOperation documents"
    connect: [ScheduledOperationConnectInput!]
    "Disconnect multiple ScheduledOperation documents"
    disconnect: [ScheduledOperationWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ScheduledOperation documents"
    set: [ScheduledOperationWhereUniqueInput!]
}

input ScheduledOperationUpdateOneInlineInput {
    "Connect existing ScheduledOperation document"
    connect: ScheduledOperationWhereUniqueInput
    "Disconnect currently connected ScheduledOperation document"
    disconnect: Boolean
}

"Identifies documents"
input ScheduledOperationWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledOperationWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledOperationWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledOperationWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String]
    "Any other value that exists and is not equal to the given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String]
    "Any other value that exists and is not equal to the given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    "All values containing the given json path."
    rawPayload_json_path_exists: String
    """

    Recursively tries to find the provided JSON scalar value inside the field.
    It does use an exact match when comparing values.
    If you pass `null` as value the filter will be ignored.
    Note: This filter fails if you try to look for a non scalar JSON value!
    """
    rawPayload_value_recursive: Json
    release: ScheduledReleaseWhereInput
    status: ScheduledOperationStatus
    "All values that are contained in given list."
    status_in: [ScheduledOperationStatus]
    "Any other value that exists and is not equal to the given value."
    status_not: ScheduledOperationStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledOperationStatus]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

"References ScheduledOperation record uniquely"
input ScheduledOperationWhereUniqueInput {
    id: ID
}

input ScheduledReleaseConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: ScheduledReleaseWhereUniqueInput!
}

input ScheduledReleaseCreateInput {
    createdAt: DateTime
    description: String
    errorMessage: String
    isActive: Boolean = true
    releaseAt: DateTime
    title: String
    updatedAt: DateTime
}

input ScheduledReleaseCreateManyInlineInput {
    "Connect multiple existing ScheduledRelease documents"
    connect: [ScheduledReleaseWhereUniqueInput!]
    "Create and connect multiple existing ScheduledRelease documents"
    create: [ScheduledReleaseCreateInput!]
}

input ScheduledReleaseCreateOneInlineInput {
    "Connect one existing ScheduledRelease document"
    connect: ScheduledReleaseWhereUniqueInput
    "Create and connect one ScheduledRelease document"
    create: ScheduledReleaseCreateInput
}

"Identifies documents"
input ScheduledReleaseManyWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledReleaseWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledReleaseWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledReleaseWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String]
    "Any other value that exists and is not equal to the given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String]
    "Any other value that exists and is not equal to the given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "Any other value that exists and is not equal to the given value."
    isActive_not: Boolean
    isImplicit: Boolean
    "Any other value that exists and is not equal to the given value."
    isImplicit_not: Boolean
    operations_every: ScheduledOperationWhereInput
    operations_none: ScheduledOperationWhereInput
    operations_some: ScheduledOperationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    releaseAt: DateTime
    "All values greater than the given value."
    releaseAt_gt: DateTime
    "All values greater than or equal the given value."
    releaseAt_gte: DateTime
    "All values that are contained in given list."
    releaseAt_in: [DateTime]
    "All values less than the given value."
    releaseAt_lt: DateTime
    "All values less than or equal the given value."
    releaseAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    releaseAt_not: DateTime
    "All values that are not contained in given list."
    releaseAt_not_in: [DateTime]
    status: ScheduledReleaseStatus
    "All values that are contained in given list."
    status_in: [ScheduledReleaseStatus]
    "Any other value that exists and is not equal to the given value."
    status_not: ScheduledReleaseStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledReleaseStatus]
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

input ScheduledReleaseUpdateInput {
    description: String
    errorMessage: String
    isActive: Boolean
    releaseAt: DateTime
    title: String
}

input ScheduledReleaseUpdateManyInlineInput {
    "Connect multiple existing ScheduledRelease documents"
    connect: [ScheduledReleaseConnectInput!]
    "Create and connect multiple ScheduledRelease documents"
    create: [ScheduledReleaseCreateInput!]
    "Delete multiple ScheduledRelease documents"
    delete: [ScheduledReleaseWhereUniqueInput!]
    "Disconnect multiple ScheduledRelease documents"
    disconnect: [ScheduledReleaseWhereUniqueInput!]
    "Override currently-connected documents with multiple existing ScheduledRelease documents"
    set: [ScheduledReleaseWhereUniqueInput!]
    "Update multiple ScheduledRelease documents"
    update: [ScheduledReleaseUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple ScheduledRelease documents"
    upsert: [ScheduledReleaseUpsertWithNestedWhereUniqueInput!]
}

input ScheduledReleaseUpdateManyInput {
    description: String
    errorMessage: String
    isActive: Boolean
    releaseAt: DateTime
    title: String
}

input ScheduledReleaseUpdateManyWithNestedWhereInput {
    "Update many input"
    data: ScheduledReleaseUpdateManyInput!
    "Document search"
    where: ScheduledReleaseWhereInput!
}

input ScheduledReleaseUpdateOneInlineInput {
    "Connect existing ScheduledRelease document"
    connect: ScheduledReleaseWhereUniqueInput
    "Create and connect one ScheduledRelease document"
    create: ScheduledReleaseCreateInput
    "Delete currently connected ScheduledRelease document"
    delete: Boolean
    "Disconnect currently connected ScheduledRelease document"
    disconnect: Boolean
    "Update single ScheduledRelease document"
    update: ScheduledReleaseUpdateWithNestedWhereUniqueInput
    "Upsert single ScheduledRelease document"
    upsert: ScheduledReleaseUpsertWithNestedWhereUniqueInput
}

input ScheduledReleaseUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: ScheduledReleaseUpdateInput!
    "Unique document search"
    where: ScheduledReleaseWhereUniqueInput!
}

input ScheduledReleaseUpsertInput {
    "Create document if it didn't exist"
    create: ScheduledReleaseCreateInput!
    "Update document if it exists"
    update: ScheduledReleaseUpdateInput!
}

input ScheduledReleaseUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: ScheduledReleaseUpsertInput!
    "Unique document search"
    where: ScheduledReleaseWhereUniqueInput!
}

"Identifies documents"
input ScheduledReleaseWhereInput {
    "Logical AND on all given filters."
    AND: [ScheduledReleaseWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [ScheduledReleaseWhereInput!]
    "Logical OR on all given filters."
    OR: [ScheduledReleaseWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    createdBy: UserWhereInput
    description: String
    "All values containing the given string."
    description_contains: String
    "All values ending with the given string."
    description_ends_with: String
    "All values that are contained in given list."
    description_in: [String]
    "Any other value that exists and is not equal to the given value."
    description_not: String
    "All values not containing the given string."
    description_not_contains: String
    "All values not ending with the given string"
    description_not_ends_with: String
    "All values that are not contained in given list."
    description_not_in: [String]
    "All values not starting with the given string."
    description_not_starts_with: String
    "All values starting with the given string."
    description_starts_with: String
    errorMessage: String
    "All values containing the given string."
    errorMessage_contains: String
    "All values ending with the given string."
    errorMessage_ends_with: String
    "All values that are contained in given list."
    errorMessage_in: [String]
    "Any other value that exists and is not equal to the given value."
    errorMessage_not: String
    "All values not containing the given string."
    errorMessage_not_contains: String
    "All values not ending with the given string"
    errorMessage_not_ends_with: String
    "All values that are not contained in given list."
    errorMessage_not_in: [String]
    "All values not starting with the given string."
    errorMessage_not_starts_with: String
    "All values starting with the given string."
    errorMessage_starts_with: String
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "Any other value that exists and is not equal to the given value."
    isActive_not: Boolean
    isImplicit: Boolean
    "Any other value that exists and is not equal to the given value."
    isImplicit_not: Boolean
    operations_every: ScheduledOperationWhereInput
    operations_none: ScheduledOperationWhereInput
    operations_some: ScheduledOperationWhereInput
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    publishedBy: UserWhereInput
    releaseAt: DateTime
    "All values greater than the given value."
    releaseAt_gt: DateTime
    "All values greater than or equal the given value."
    releaseAt_gte: DateTime
    "All values that are contained in given list."
    releaseAt_in: [DateTime]
    "All values less than the given value."
    releaseAt_lt: DateTime
    "All values less than or equal the given value."
    releaseAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    releaseAt_not: DateTime
    "All values that are not contained in given list."
    releaseAt_not_in: [DateTime]
    status: ScheduledReleaseStatus
    "All values that are contained in given list."
    status_in: [ScheduledReleaseStatus]
    "Any other value that exists and is not equal to the given value."
    status_not: ScheduledReleaseStatus
    "All values that are not contained in given list."
    status_not_in: [ScheduledReleaseStatus]
    title: String
    "All values containing the given string."
    title_contains: String
    "All values ending with the given string."
    title_ends_with: String
    "All values that are contained in given list."
    title_in: [String]
    "Any other value that exists and is not equal to the given value."
    title_not: String
    "All values not containing the given string."
    title_not_contains: String
    "All values not ending with the given string"
    title_not_ends_with: String
    "All values that are not contained in given list."
    title_not_in: [String]
    "All values not starting with the given string."
    title_not_starts_with: String
    "All values starting with the given string."
    title_starts_with: String
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
    updatedBy: UserWhereInput
}

"References ScheduledRelease record uniquely"
input ScheduledReleaseWhereUniqueInput {
    id: ID
}

input UnpublishLocaleInput {
    "Locales to unpublish"
    locale: Locale!
    "Stages to unpublish selected locales from"
    stages: [Stage!]!
}

input UserConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: UserWhereUniqueInput!
}

input UserCreateManyInlineInput {
    "Connect multiple existing User documents"
    connect: [UserWhereUniqueInput!]
}

input UserCreateOneInlineInput {
    "Connect one existing User document"
    connect: UserWhereUniqueInput
}

"Identifies documents"
input UserManyWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    documentInStages_every: UserWhereStageInput
    documentInStages_none: UserWhereStageInput
    documentInStages_some: UserWhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "Any other value that exists and is not equal to the given value."
    isActive_not: Boolean
    kind: UserKind
    "All values that are contained in given list."
    kind_in: [UserKind]
    "Any other value that exists and is not equal to the given value."
    kind_not: UserKind
    "All values that are not contained in given list."
    kind_not_in: [UserKind]
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String]
    "Any other value that exists and is not equal to the given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    picture: String
    "All values containing the given string."
    picture_contains: String
    "All values ending with the given string."
    picture_ends_with: String
    "All values that are contained in given list."
    picture_in: [String]
    "Any other value that exists and is not equal to the given value."
    picture_not: String
    "All values not containing the given string."
    picture_not_contains: String
    "All values not ending with the given string"
    picture_not_ends_with: String
    "All values that are not contained in given list."
    picture_not_in: [String]
    "All values not starting with the given string."
    picture_not_starts_with: String
    "All values starting with the given string."
    picture_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
}

input UserUpdateManyInlineInput {
    "Connect multiple existing User documents"
    connect: [UserConnectInput!]
    "Disconnect multiple User documents"
    disconnect: [UserWhereUniqueInput!]
    "Override currently-connected documents with multiple existing User documents"
    set: [UserWhereUniqueInput!]
}

input UserUpdateOneInlineInput {
    "Connect existing User document"
    connect: UserWhereUniqueInput
    "Disconnect currently connected User document"
    disconnect: Boolean
}

"This contains a set of filters that can be used to compare values internally"
input UserWhereComparatorInput {
    "This field can be used to request to check if the entry is outdated by internal comparison"
    outdated_to: Boolean
}

"Identifies documents"
input UserWhereInput {
    "Logical AND on all given filters."
    AND: [UserWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereInput!]
    "Logical OR on all given filters."
    OR: [UserWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime]
    documentInStages_every: UserWhereStageInput
    documentInStages_none: UserWhereStageInput
    documentInStages_some: UserWhereStageInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID]
    "Any other value that exists and is not equal to the given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    isActive: Boolean
    "Any other value that exists and is not equal to the given value."
    isActive_not: Boolean
    kind: UserKind
    "All values that are contained in given list."
    kind_in: [UserKind]
    "Any other value that exists and is not equal to the given value."
    kind_not: UserKind
    "All values that are not contained in given list."
    kind_not_in: [UserKind]
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String]
    "Any other value that exists and is not equal to the given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    picture: String
    "All values containing the given string."
    picture_contains: String
    "All values ending with the given string."
    picture_ends_with: String
    "All values that are contained in given list."
    picture_in: [String]
    "Any other value that exists and is not equal to the given value."
    picture_not: String
    "All values not containing the given string."
    picture_not_contains: String
    "All values not ending with the given string"
    picture_not_ends_with: String
    "All values that are not contained in given list."
    picture_not_in: [String]
    "All values not starting with the given string."
    picture_not_starts_with: String
    "All values starting with the given string."
    picture_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "Any other value that exists and is not equal to the given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime]
}

"The document in stages filter allows specifying a stage entry to cross compare the same document between different stages"
input UserWhereStageInput {
    "Logical AND on all given filters."
    AND: [UserWhereStageInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [UserWhereStageInput!]
    "Logical OR on all given filters."
    OR: [UserWhereStageInput!]
    "This field contains fields which can be set as true or false to specify an internal comparison"
    compareWithParent: UserWhereComparatorInput
    "Specify the stage to compare with"
    stage: Stage
}

"References User record uniquely"
input UserWhereUniqueInput {
    id: ID
}

input VersionWhereInput {
    id: ID!
    revision: Int!
    stage: Stage!
}

input multiToManyReferenceMultiToManyReferenceConnectInput {
    Model1: Model1ConnectInput
    Model3: Model3ConnectInput
}

input multiToManyReferenceMultiToManyReferenceCreateInput {
    Model1: Model1CreateInput
    Model3: Model3CreateInput
}

input multiToManyReferenceMultiToManyReferenceCreateManyInlineInput {
    "Connect multiple existing multiToManyReferenceMultiToManyReference documents"
    connect: [multiToManyReferenceMultiToManyReferenceWhereUniqueInput!]
    "Create and connect multiple existing multiToManyReferenceMultiToManyReference documents"
    create: [multiToManyReferenceMultiToManyReferenceCreateInput!]
}

input multiToManyReferenceMultiToManyReferenceCreateOneInlineInput {
    "Connect one existing multiToManyReferenceMultiToManyReference document"
    connect: multiToManyReferenceMultiToManyReferenceWhereUniqueInput
    "Create and connect one multiToManyReferenceMultiToManyReference document"
    create: multiToManyReferenceMultiToManyReferenceCreateInput
}

input multiToManyReferenceMultiToManyReferenceUpdateInput {
    Model1: Model1UpdateInput
    Model3: Model3UpdateInput
}

input multiToManyReferenceMultiToManyReferenceUpdateManyInlineInput {
    "Connect multiple existing multiToManyReferenceMultiToManyReference documents"
    connect: [multiToManyReferenceMultiToManyReferenceConnectInput!]
    "Create and connect multiple multiToManyReferenceMultiToManyReference documents"
    create: [multiToManyReferenceMultiToManyReferenceCreateInput!]
    "Delete multiple multiToManyReferenceMultiToManyReference documents"
    delete: [multiToManyReferenceMultiToManyReferenceWhereUniqueInput!]
    "Disconnect multiple multiToManyReferenceMultiToManyReference documents"
    disconnect: [multiToManyReferenceMultiToManyReferenceWhereUniqueInput!]
    "Override currently-connected documents with multiple existing multiToManyReferenceMultiToManyReference documents"
    set: [multiToManyReferenceMultiToManyReferenceWhereUniqueInput!]
    "Update multiple multiToManyReferenceMultiToManyReference documents"
    update: [multiToManyReferenceMultiToManyReferenceUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple multiToManyReferenceMultiToManyReference documents"
    upsert: [multiToManyReferenceMultiToManyReferenceUpsertWithNestedWhereUniqueInput!]
}

input multiToManyReferenceMultiToManyReferenceUpdateManyWithNestedWhereInput {
    Model1: Model1UpdateManyWithNestedWhereInput
    Model3: Model3UpdateManyWithNestedWhereInput
}

input multiToManyReferenceMultiToManyReferenceUpdateOneInlineInput {
    "Connect existing multiToManyReferenceMultiToManyReference document"
    connect: multiToManyReferenceMultiToManyReferenceWhereUniqueInput
    "Create and connect one multiToManyReferenceMultiToManyReference document"
    create: multiToManyReferenceMultiToManyReferenceCreateInput
    "Delete currently connected multiToManyReferenceMultiToManyReference document"
    delete: Boolean
    "Disconnect currently connected multiToManyReferenceMultiToManyReference document"
    disconnect: Boolean
    "Update single multiToManyReferenceMultiToManyReference document"
    update: multiToManyReferenceMultiToManyReferenceUpdateWithNestedWhereUniqueInput
    "Upsert single multiToManyReferenceMultiToManyReference document"
    upsert: multiToManyReferenceMultiToManyReferenceUpsertWithNestedWhereUniqueInput
}

input multiToManyReferenceMultiToManyReferenceUpdateWithNestedWhereUniqueInput {
    Model1: Model1UpdateWithNestedWhereUniqueInput
    Model3: Model3UpdateWithNestedWhereUniqueInput
}

input multiToManyReferenceMultiToManyReferenceUpsertWithNestedWhereUniqueInput {
    Model1: Model1UpsertWithNestedWhereUniqueInput
    Model3: Model3UpsertWithNestedWhereUniqueInput
}

input multiToManyReferenceMultiToManyReferenceWhereInput {
    Model1: Model1WhereInput
    Model3: Model3WhereInput
}

input multiToManyReferenceMultiToManyReferenceWhereUniqueInput {
    Model1: Model1WhereUniqueInput
    Model3: Model3WhereUniqueInput
}

input singleToManyReference2MultiToOneReference2ConnectInput {
    Model1: Model1ConnectInput
    Model3: Model3ConnectInput
}

input singleToManyReference2MultiToOneReference2CreateInput {
    Model1: Model1CreateInput
    Model3: Model3CreateInput
}

input singleToManyReference2MultiToOneReference2CreateManyInlineInput {
    "Connect multiple existing singleToManyReference2MultiToOneReference2 documents"
    connect: [singleToManyReference2MultiToOneReference2WhereUniqueInput!]
    "Create and connect multiple existing singleToManyReference2MultiToOneReference2 documents"
    create: [singleToManyReference2MultiToOneReference2CreateInput!]
}

input singleToManyReference2MultiToOneReference2CreateOneInlineInput {
    "Connect one existing singleToManyReference2MultiToOneReference2 document"
    connect: singleToManyReference2MultiToOneReference2WhereUniqueInput
    "Create and connect one singleToManyReference2MultiToOneReference2 document"
    create: singleToManyReference2MultiToOneReference2CreateInput
}

input singleToManyReference2MultiToOneReference2UpdateInput {
    Model1: Model1UpdateInput
    Model3: Model3UpdateInput
}

input singleToManyReference2MultiToOneReference2UpdateManyInlineInput {
    "Connect multiple existing singleToManyReference2MultiToOneReference2 documents"
    connect: [singleToManyReference2MultiToOneReference2ConnectInput!]
    "Create and connect multiple singleToManyReference2MultiToOneReference2 documents"
    create: [singleToManyReference2MultiToOneReference2CreateInput!]
    "Delete multiple singleToManyReference2MultiToOneReference2 documents"
    delete: [singleToManyReference2MultiToOneReference2WhereUniqueInput!]
    "Disconnect multiple singleToManyReference2MultiToOneReference2 documents"
    disconnect: [singleToManyReference2MultiToOneReference2WhereUniqueInput!]
    "Override currently-connected documents with multiple existing singleToManyReference2MultiToOneReference2 documents"
    set: [singleToManyReference2MultiToOneReference2WhereUniqueInput!]
    "Update multiple singleToManyReference2MultiToOneReference2 documents"
    update: [singleToManyReference2MultiToOneReference2UpdateWithNestedWhereUniqueInput!]
    "Upsert multiple singleToManyReference2MultiToOneReference2 documents"
    upsert: [singleToManyReference2MultiToOneReference2UpsertWithNestedWhereUniqueInput!]
}

input singleToManyReference2MultiToOneReference2UpdateManyWithNestedWhereInput {
    Model1: Model1UpdateManyWithNestedWhereInput
    Model3: Model3UpdateManyWithNestedWhereInput
}

input singleToManyReference2MultiToOneReference2UpdateOneInlineInput {
    "Connect existing singleToManyReference2MultiToOneReference2 document"
    connect: singleToManyReference2MultiToOneReference2WhereUniqueInput
    "Create and connect one singleToManyReference2MultiToOneReference2 document"
    create: singleToManyReference2MultiToOneReference2CreateInput
    "Delete currently connected singleToManyReference2MultiToOneReference2 document"
    delete: Boolean
    "Disconnect currently connected singleToManyReference2MultiToOneReference2 document"
    disconnect: Boolean
    "Update single singleToManyReference2MultiToOneReference2 document"
    update: singleToManyReference2MultiToOneReference2UpdateWithNestedWhereUniqueInput
    "Upsert single singleToManyReference2MultiToOneReference2 document"
    upsert: singleToManyReference2MultiToOneReference2UpsertWithNestedWhereUniqueInput
}

input singleToManyReference2MultiToOneReference2UpdateWithNestedWhereUniqueInput {
    Model1: Model1UpdateWithNestedWhereUniqueInput
    Model3: Model3UpdateWithNestedWhereUniqueInput
}

input singleToManyReference2MultiToOneReference2UpsertWithNestedWhereUniqueInput {
    Model1: Model1UpsertWithNestedWhereUniqueInput
    Model3: Model3UpsertWithNestedWhereUniqueInput
}

input singleToManyReference2MultiToOneReference2WhereInput {
    Model1: Model1WhereInput
    Model3: Model3WhereInput
}

input singleToManyReference2MultiToOneReference2WhereUniqueInput {
    Model1: Model1WhereUniqueInput
    Model3: Model3WhereUniqueInput
}

input singleToOneReferenceMultiToOneReferenceConnectInput {
    Model1: Model1ConnectInput
    Model3: Model3ConnectInput
}

input singleToOneReferenceMultiToOneReferenceCreateInput {
    Model1: Model1CreateInput
    Model3: Model3CreateInput
}

input singleToOneReferenceMultiToOneReferenceCreateManyInlineInput {
    "Connect multiple existing singleToOneReferenceMultiToOneReference documents"
    connect: [singleToOneReferenceMultiToOneReferenceWhereUniqueInput!]
    "Create and connect multiple existing singleToOneReferenceMultiToOneReference documents"
    create: [singleToOneReferenceMultiToOneReferenceCreateInput!]
}

input singleToOneReferenceMultiToOneReferenceCreateOneInlineInput {
    "Connect one existing singleToOneReferenceMultiToOneReference document"
    connect: singleToOneReferenceMultiToOneReferenceWhereUniqueInput
    "Create and connect one singleToOneReferenceMultiToOneReference document"
    create: singleToOneReferenceMultiToOneReferenceCreateInput
}

input singleToOneReferenceMultiToOneReferenceUpdateInput {
    Model1: Model1UpdateInput
    Model3: Model3UpdateInput
}

input singleToOneReferenceMultiToOneReferenceUpdateManyInlineInput {
    "Connect multiple existing singleToOneReferenceMultiToOneReference documents"
    connect: [singleToOneReferenceMultiToOneReferenceConnectInput!]
    "Create and connect multiple singleToOneReferenceMultiToOneReference documents"
    create: [singleToOneReferenceMultiToOneReferenceCreateInput!]
    "Delete multiple singleToOneReferenceMultiToOneReference documents"
    delete: [singleToOneReferenceMultiToOneReferenceWhereUniqueInput!]
    "Disconnect multiple singleToOneReferenceMultiToOneReference documents"
    disconnect: [singleToOneReferenceMultiToOneReferenceWhereUniqueInput!]
    "Override currently-connected documents with multiple existing singleToOneReferenceMultiToOneReference documents"
    set: [singleToOneReferenceMultiToOneReferenceWhereUniqueInput!]
    "Update multiple singleToOneReferenceMultiToOneReference documents"
    update: [singleToOneReferenceMultiToOneReferenceUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple singleToOneReferenceMultiToOneReference documents"
    upsert: [singleToOneReferenceMultiToOneReferenceUpsertWithNestedWhereUniqueInput!]
}

input singleToOneReferenceMultiToOneReferenceUpdateManyWithNestedWhereInput {
    Model1: Model1UpdateManyWithNestedWhereInput
    Model3: Model3UpdateManyWithNestedWhereInput
}

input singleToOneReferenceMultiToOneReferenceUpdateOneInlineInput {
    "Connect existing singleToOneReferenceMultiToOneReference document"
    connect: singleToOneReferenceMultiToOneReferenceWhereUniqueInput
    "Create and connect one singleToOneReferenceMultiToOneReference document"
    create: singleToOneReferenceMultiToOneReferenceCreateInput
    "Delete currently connected singleToOneReferenceMultiToOneReference document"
    delete: Boolean
    "Disconnect currently connected singleToOneReferenceMultiToOneReference document"
    disconnect: Boolean
    "Update single singleToOneReferenceMultiToOneReference document"
    update: singleToOneReferenceMultiToOneReferenceUpdateWithNestedWhereUniqueInput
    "Upsert single singleToOneReferenceMultiToOneReference document"
    upsert: singleToOneReferenceMultiToOneReferenceUpsertWithNestedWhereUniqueInput
}

input singleToOneReferenceMultiToOneReferenceUpdateWithNestedWhereUniqueInput {
    Model1: Model1UpdateWithNestedWhereUniqueInput
    Model3: Model3UpdateWithNestedWhereUniqueInput
}

input singleToOneReferenceMultiToOneReferenceUpsertWithNestedWhereUniqueInput {
    Model1: Model1UpsertWithNestedWhereUniqueInput
    Model3: Model3UpsertWithNestedWhereUniqueInput
}

input singleToOneReferenceMultiToOneReferenceWhereInput {
    Model1: Model1WhereInput
    Model3: Model3WhereInput
}

input singleToOneReferenceMultiToOneReferenceWhereUniqueInput {
    Model1: Model1WhereUniqueInput
    Model3: Model3WhereUniqueInput
}
